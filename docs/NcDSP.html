<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--                                             -->
<!-- Author: ROOT team (rootdev@cern.ch)         -->
<!--                                             -->
<!--   Date: Tue Dec  5 12:09:06 2023            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>NcDSP</title>
<meta name="rating" content="General" />
<meta name="objecttype" content="Manual" />
<meta name="keywords" content="software development, oo, object oriented, unix, x11, windows, c++, html, rene brun, fons rademakers, cern" />
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis." />
<link rel="stylesheet" type="text/css" href="ROOT.css" id="ROOTstyle" />
<script type="text/javascript" src="ROOT.js"></script>
</head>
<body  onload="javascript:SetValuesFromCookie();"><div id="body_content">
<div id="root_header"><img src="http://root.cern.ch/drupal/sites/default/files/rootdrawing-logo.png" alt="ROOT logo"/></div>
<a name="TopOfPage"></a>
<script type="text/javascript">WriteFollowPageBox('class NcDSP','','NcDSP.h');</script>
<div id="toplinks">
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Quick Links:</span>
<a class="descrheadentry" href="http://root.cern.ch">ROOT Homepage</a>
<a class="descrheadentry" href="./ClassIndex.html">Class Index</a>
<a class="descrheadentry" href="./ClassHierarchy.html">Class Hierarchy</a></div>
<script type="text/javascript">
function onSearch() {
var s='http://www.google.com/search?q=%s+site%3A%u+-site%3A%u%2Fsrc%2F+-site%3A%u%2Fexamples%2F';
var ref=String(document.location.href).replace(/https?:\/\//,'').replace(/\/[^\/]*$/,'').replace(/\//g,'%2F');
window.location.href=s.replace(/%u/ig,ref).replace(/%s/ig,escape(document.searchform.t.value));
return false;}
</script>
<form id="searchform" name="searchform" onsubmit="return onSearch()" action="javascript:onSearch();" method="post">
<input name="t" size="30" value="Search documentation..." onfocus="if (document.searchform.t.value=='Search documentation...') document.searchform.t.value='';"></input>
<a id="searchlink"  title="www.google.com"  href="javascript:onSearch();" onclick="return onSearch()">Search</a></form>
</div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Source:</span>
<a class="descrheadentry" href="src/NcDSP.h.html">header file</a>
<a class="descrheadentry" href="src/NcDSP.cxx.html">source file</a>
<a class="descrheadentry" href="NcDSP_Tree.pdf">inheritance tree (.pdf)</a> 
</div></div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Sections:</span>
<a class="descrheadentry" href="#NcDSP:description">class description</a> 
<a class="descrheadentry" href="#NcDSP:Function_Members">function members</a>
<a class="descrheadentry" href="#NcDSP:Data_Members">data members</a>
<a class="descrheadentry" href="#NcDSP:Class_Charts">class charts</a>
</div></div>
</div>
<div class="location">
<a class="locationlevel" href="index.html">NCFS</a>
 &#187; <a class="locationlevel" href="./SOURCE_Index.html">SOURCE</a>
 &#187; <a class="locationlevel" href="#TopOfPage">NcDSP</a>
</div>
<div class="dropshadow"><div class="withshadow"><h1><a name="NcDSP:description"></a>class NcDSP: public TNamed</h1>
<div class="classdescr">
<pre>
 <a href="./NcDSP.html#NcDSP:Class" title="TClass* NcDSP::Class()">Class</a> <a href="./NcDSP.html">NcDSP</a>
 <a href="./NcDSP.html#NcDSP:Class" title="TClass* NcDSP::Class()">Class</a> to perform various Digital Signal Processing (DSP) operations on (sequential) data samples.

 For a description of most of the DSP techniques, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 The following discrete transformations (using the FFTW algorithms) are supported :
 <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> (DFT), <a href="./NcDSP.html#NcDSP:Hartley" title="void NcDSP::Hartley(Int_t mode,TH1* hist=0,TString sel=&quot;none&quot;)">Hartley</a> (DHT), <a href="./NcDSP.html#NcDSP:Sine" title="void NcDSP::Sine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Sine</a> (DST) and <a href="./NcDSP.html#NcDSP:Cosine" title="void NcDSP::Cosine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Cosine</a> (DCT).

 All transformation results have been normalized, such that
 the inverse transformation provides the original input spectrum.

 In addition to the above transformations, also convolution, correlation,
 filter, Analog to Digital Converter (<a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>), Digital to Analog Converter (<a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>)
 and <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>-<a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> chain transmission processors are provided.

 For details about the various operations and their options, please refer
 to the documentation in the corresponding member functions.

 Usage example for a discrete <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform (DFT) :


 <a href="./ListOfTypes.html#Int_t">Int_t</a> N=2048;          // Number of samples
 <a href="./ListOfTypes.html#Float_t">Float_t</a> fsample=3.2e9; // Sampling rate in Hz
 <a href="./ListOfTypes.html#Float_t">Float_t</a> nu=3e8;        // Signal frequency in Hz

 <a href="./ListOfTypes.html#Float_t">Float_t</a> pi=acos(-1.);
 <a href="./ListOfTypes.html#Float_t">Float_t</a> omega=2.*pi*nu;  // Signal frequency in rad/sec
 <a href="./ListOfTypes.html#Float_t">Float_t</a> step=1./fsample; // The time step of each sample

 // Fill the time domain sampled data
 <a href="./ListOfTypes.html#Double_t">Double_t</a> tdata[N];
 <a href="./ListOfTypes.html#Float_t">Float_t</a> t=0;
 <a href="./ListOfTypes.html#Float_t">Float_t</a> y=0;
 for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i=0; i&lt;N; i++)
 {
  y=cos(omega*t)+5.*sin(3.*omega*t);
  tdata[i]=y;
  t+=step;
 }

 <a href="./NcDSP.html">NcDSP</a> q;
 q.<a href="./NcDSP.html#NcDSP:SetSamplingFrequency" title="void NcDSP::SetSamplingFrequency(Float_t f)">SetSamplingFrequency</a>(fsample);
 q.<a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>(N,tdata);

 // Obtain the amplitudes in an array
 q.<a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a>(<span class="string">"R2C"</span>);
 TArrayD arr=q.<a href="./NcDSP.html#NcDSP:GetData" title="TArrayD NcDSP::GetData(TString mode)">GetData</a>(<span class="string">"AMP out"</span>);

 // Obtain the amplitudes in a histogram
 TH1F hist;
 q.<a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a>(<span class="string">"R2C"</span>,&amp;hist,<span class="string">"AMP Hz"</span>);

 // Illustration of forward followed by inverse transformation

 // The original time domain input spectrum
 TH1F hist1;
 q.<a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a>(<span class="string">"R2C"</span>,&amp;hist1,<span class="string">"t"</span>);

 // The forward transformation
 TH1F hist2;
 q.<a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a>(<span class="string">"R2C"</span>,&amp;hist2,<span class="string">"AMP Hz"</span>);

 // <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> the obtained frequency domain data as new input to obtain
 // the original time domain spectrum via the inverse transformation
 q.<a href="./NcDSP.html#NcDSP:LoadResult" title="void NcDSP::LoadResult()">LoadResult</a>();

 // The frequency domain input spectrum
 TH1F hist3;
 q.<a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a>(<span class="string">"C2R"</span>,&amp;hist3,<span class="string">"AMP Hz"</span>);

 // Obtain the original time domain spectrum via the inverse transformation
 TH1F hist4;
 q.<a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a>(<span class="string">"C2R"</span>,&amp;hist4,<span class="string">"t"</span>);

 TCanvas c1(<span class="string">"c1"</span>,<span class="string">"Forward"</span>);
 c1.Divide(1,2);
 c1.cd(1);
 hist1.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();
 c1.cd(2);
 hist2.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();

 TCanvas c2(<span class="string">"c2"</span>,<span class="string">"Inverse"</span>);
 c2.Divide(1,2);
 c2.cd(1);
 hist3.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();
 c2.cd(2);
 hist4.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();

 Usage example for Convolution :


 // The input signal
 const <a href="./ListOfTypes.html#Int_t">Int_t</a> nx=17;
 <a href="./ListOfTypes.html#Double_t">Double_t</a> x[nx]={0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0};

 // The system impulse response
 const <a href="./ListOfTypes.html#Int_t">Int_t</a> nh=10;
 <a href="./ListOfTypes.html#Double_t">Double_t</a> h[nh]={1,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1};

 <a href="./NcDSP.html">NcDSP</a> q;
 q.<a href="./NcDSP.html#NcDSP:SetSamplingFrequency" title="void NcDSP::SetSamplingFrequency(Float_t f)">SetSamplingFrequency</a>(1e9); // Sampling frequency in Hz
 q.<a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>(nx,x);                // <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> the signal input data
 q.<a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>(nh,h);         // <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> the system response data

 printf(<span class="string">" Stored elements : Nsignal=%-i  Nwaveform=%-i \n"</span>,q.<a href="./NcDSP.html#NcDSP:GetN" title="Int_t NcDSP::GetN(Int_t mode=0)">GetN</a>(),q.<a href="./NcDSP.html#NcDSP:GetN" title="Int_t NcDSP::GetN(Int_t mode=0)">GetN</a>(1));

 // Perform the Convolution
 TH1F hy;
 <a href="./ListOfTypes.html#Int_t">Int_t</a> smin,smax;
 TArrayD y=q.<a href="./NcDSP.html#NcDSP:Convolve" title="TArrayD NcDSP::Convolve(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Int_t shift=0)">Convolve</a>(&amp;hy,&amp;smin,&amp;smax);

 printf(<span class="string">" Convolution full coverage between sample numbers %-i and %-i \n"</span>,smin,smax);

 // Plot the various distributions
 TH1F hx(<span class="string">"hx"</span>,<span class="string">"Input signal"</span>,nx,0,nx);
 for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i=1; i&lt;=nx; i++)
 {
  hx.SetBinContent(i,x[i-1]);
 }

 TH1F hh(<span class="string">"hh"</span>,<span class="string">"Impulse response"</span>,nh,0,nh);
 for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i=1; i&lt;=nh; i++)
 {
  hh.SetBinContent(i,h[i-1]);
 }

 TCanvas c(<span class="string">"c"</span>,<span class="string">"Convolution"</span>);
 c.Divide(1,3);
 c.cd(1);
 hx.SetMarkerStyle(20);
 hx.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"P"</span>);
 c.cd(2);
 hh.SetMarkerStyle(20);
 hh.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"P"</span>);
 c.cd(3);
 hy.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"P"</span>);

 Usage example for cross-correlation :


 // The input signal
 const <a href="./ListOfTypes.html#Int_t">Int_t</a> nx=17;
 <a href="./ListOfTypes.html#Double_t">Double_t</a> x[nx]={0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0};

 // The waveform pattern
 const <a href="./ListOfTypes.html#Int_t">Int_t</a> nh=10;
 <a href="./ListOfTypes.html#Double_t">Double_t</a> h[nh]={1,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1};

 <a href="./NcDSP.html">NcDSP</a> q;
 q.<a href="./NcDSP.html#NcDSP:SetSamplingFrequency" title="void NcDSP::SetSamplingFrequency(Float_t f)">SetSamplingFrequency</a>(1e9); // Sampling frequency in Hz
 q.<a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>(nx,x);                // <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> the signal input data
 q.<a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>(nh,h);         // <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> the waveform data

 printf(<span class="string">" Stored elements : Nsignal=%-i  Nwaveform=%-i \n"</span>,q.<a href="./NcDSP.html#NcDSP:GetN" title="Int_t NcDSP::GetN(Int_t mode=0)">GetN</a>(),q.<a href="./NcDSP.html#NcDSP:GetN" title="Int_t NcDSP::GetN(Int_t mode=0)">GetN</a>(1));

 // Perform the Cross-Correlation
 TH1F hy;
 <a href="./ListOfTypes.html#Int_t">Int_t</a> smin,smax;
 TArrayD y=q.<a href="./NcDSP.html#NcDSP:Correlate" title="TArrayD NcDSP::Correlate(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Double_t* peak=0)">Correlate</a>(&amp;hy,&amp;smin,&amp;smax);

 printf(<span class="string">" Correlation full coverage between sample numbers %-i and %-i \n"</span>,smin,smax);

 // Plot the various distributions
 TH1F hx(<span class="string">"hx"</span>,<span class="string">"Input signal"</span>,nx,0,nx);
 for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i=1; i&lt;=nx; i++)
 {
  hx.SetBinContent(i,x[i-1]);
 }

 TH1F hh(<span class="string">"hh"</span>,<span class="string">"Waveform pattern"</span>,nh,0,nh);
 for (<a href="./ListOfTypes.html#Int_t">Int_t</a> i=1; i&lt;=nh; i++)
 {
  hh.SetBinContent(i,h[i-1]);
 }

 TCanvas c(<span class="string">"c"</span>,<span class="string">"Correlation"</span>);
 c.Divide(1,3);
 c.cd(1);
 hx.SetMarkerStyle(20);
 hx.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"P"</span>);
 c.cd(2);
 hh.SetMarkerStyle(20);
 hh.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"P"</span>);
 c.cd(3);
 hy.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>(<span class="string">"P"</span>);

 Usage example for a Band Pass filter :


 <a href="./NcDSP.html">NcDSP</a> q;
 <a href="./ListOfTypes.html#Float_t">Float_t</a> fsample=1e9; // Sampling frequency in Hz
 q.<a href="./NcDSP.html#NcDSP:SetSamplingFrequency" title="void NcDSP::SetSamplingFrequency(Float_t f)">SetSamplingFrequency</a>(fsample);
 q.<a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>(nx,x);                    // <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> some signal input data
 <a href="./ListOfTypes.html#Double_t">Double_t</a> f1=200e6/fsample;       // The lower bound (200 MHz) of the frequency band
 <a href="./ListOfTypes.html#Double_t">Double_t</a> f2=300e6/fsample;       // The upper bound (300 MHz) of the frequency band
 <a href="./ListOfTypes.html#Int_t">Int_t</a> n=101;     // The number of points describing the filter kernel
 TH1F hisf;       // The frequency domain histogram
 TH1F hist;       // The time domain histogram
 <a href="./ListOfTypes.html#Int_t">Int_t</a> imin,imax; // The sample number boundaries of the signal for which the kernel is fully embedded

 // Perform the filtering
 q.<a href="./NcDSP.html#NcDSP:FilterBandPass" title="TArrayD NcDSP::FilterBandPass(Double_t f1,Double_t f2,Int_t n,TH1* hisf=0,Bool_t dB=kTRUE,TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Bool_t adaptn=kTRUE)">FilterBandPass</a>(f1,f2,n,&amp;hisf,&amp;hist,&amp;imin,&amp;imax);

 printf(<span class="string">" Filter kernel full coverage between sample numbers %-i and %-i \n"</span>,imin,imax);

 TCanvas cf(<span class="string">"cf"</span>,<span class="string">"cf"</span>);
 hisf.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();
 TCanvas ct(<span class="string">"ct"</span>,<span class="string">"ct"</span>);
 hist.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();

 Usage example for a Multi Band filter :


 <a href="./NcDSP.html">NcDSP</a> q;
 <a href="./ListOfTypes.html#Float_t">Float_t</a> fsample=1e9; // Sampling frequency in Hz
 q.<a href="./NcDSP.html#NcDSP:SetSamplingFrequency" title="void NcDSP::SetSamplingFrequency(Float_t f)">SetSamplingFrequency</a>(fsample);
 q.<a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>(nx,x);                // <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> some signal input data
 <a href="./ListOfTypes.html#Double_t">Double_t</a> f1=200e6/fsample;   // The lower bound (200 MHz) of the 1st frequency band
 <a href="./ListOfTypes.html#Double_t">Double_t</a> f2=300e6/fsample;   // The upper bound (300 MHz) of the 1st frequency band
 <a href="./ListOfTypes.html#Double_t">Double_t</a> f3=450e6/fsample;   // The lower bound (450 MHz) of the 2nd frequency band
 <a href="./ListOfTypes.html#Double_t">Double_t</a> f4=550e6/fsample;   // The upper bound (550 MHz) of the 2nd frequency band
 TArrayF freqs(4); // Specification of the frequency bands
 freqs[0]=f1;
 freqs[1]=f2;
 freqs[2]=f3;
 freqs[3]=f4;
 <a href="./ListOfTypes.html#Int_t">Int_t</a> n=101;     // The number of points describing the filter kernel
 TH1F hisf;       // The frequency domain histogram
 TH1F hist;       // The time domain histogram
 <a href="./ListOfTypes.html#Int_t">Int_t</a> imin,imax; // The sample number boundaries of the signal for which the kernel is fully embedded

 // Perform the filtering
 q.<a href="./NcDSP.html#NcDSP:FilterMultiBand" title="TArrayD NcDSP::FilterMultiBand(TArray&amp; freqs,Int_t n,TH1* hisf=0,Bool_t dB=kTRUE,TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Bool_t adaptn=kTRUE)">FilterMultiBand</a>(freqs,n,&amp;hisf,&amp;hist,&amp;imin,&amp;imax);

 printf(<span class="string">" Filter kernel full coverage between sample numbers %-i and %-i \n"</span>,imin,imax);

 TCanvas cf(<span class="string">"cf"</span>,<span class="string">"cf"</span>);
 hisf.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();
 TCanvas ct(<span class="string">"ct"</span>,<span class="string">"ct"</span>);
 hist.<a href="./#TObject:Draw" title="void TObject::Draw(Option_t* option=&quot;&quot;)">Draw</a>();


--- Author: Nick van Eijndhoven, IIHE-VUB, Brussel, October 19, 2021  09:42Z
- Modified: Nick van Eijndhoven, IIHE-VUB, Brussel, December 5, 2023  09:26Z

</pre></div>
</div></div>

<div id="functions">
<h2><a id="NcDSP:Function_Members"></a>Function Members (Methods)</h2>
<div class="access" id="funcpubl"><b>public:</b>
<table class="func" id="tabfuncpubl" cellspacing="0">
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#NcDSP:NcDSP@1">NcDSP</a>(<span class="keyword">const</span> <a href="./NcDSP.html">NcDSP</a>&amp; q)</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#NcDSP:NcDSP">NcDSP</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* title = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret"> virtual</td><td class="funcname"><a class="funcname" href="#NcDSP:_NcDSP">~NcDSP</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:AbstractMethod"><span class="baseclass">TObject::</span>AbstractMethod</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayL64</td><td class="funcname"><a class="funcname" href="#NcDSP:ADC">ADC</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> range, <a href="./ListOfTypes.html#Double_t">Double_t</a> Vbias = 0, TArray* Vsig = 0, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> B = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> C = 3) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:AppendPad"><span class="baseclass">TObject::</span>AppendPad</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Browse"><span class="baseclass">TObject::</span>Browse</a>(TBrowser* b)</td></tr>
<tr class="func"><td class="funcret">static TClass*</td><td class="funcname"><a class="funcname" href="#NcDSP:Class">Class</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TObject:ClassName"><span class="baseclass">TObject::</span>ClassName</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:Clear"><span class="baseclass">TNamed::</span>Clear</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>*</td><td class="funcname"><a class="funcname" href="#NcDSP:Clone">Clone</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TNamed:Compare"><span class="baseclass">TNamed::</span>Compare</a>(<span class="keyword">const</span> <a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:Convolve">Convolve</a>(TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> shift = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:Copy"><span class="baseclass">TNamed::</span>Copy</a>(<a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>&amp; named) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:Correlate">Correlate</a>(TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a>* peak = 0)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Cosine">Cosine</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> type, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:DAC">DAC</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> range, <a href="./ListOfTypes.html#Double_t">Double_t</a> Vbias = 0, TArray* adcs = 0, TArray* peds = 0, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> B = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> C = 3) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Delete"><span class="baseclass">TObject::</span>Delete</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:Digitize">Digitize</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> vcal, <a href="./ListOfTypes.html#Int_t">Int_t</a> mode, TH1* hist = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a>* stp = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a>* scale = 0) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TObject:DistancetoPrimitive"><span class="baseclass">TObject::</span>DistancetoPrimitive</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Draw"><span class="baseclass">TObject::</span>Draw</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:DrawClass"><span class="baseclass">TObject::</span>DrawClass</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>*</td><td class="funcname"><a class="funcname" href="#TObject:DrawClone"><span class="baseclass">TObject::</span>DrawClone</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Dump"><span class="baseclass">TObject::</span>Dump</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Error"><span class="baseclass">TObject::</span>Error</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Execute"><span class="baseclass">TObject::</span>Execute</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* params, <a href="./ListOfTypes.html#Int_t">Int_t</a>* error = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Execute@1"><span class="baseclass">TObject::</span>Execute</a>(TMethod* method, TObjArray* params, <a href="./ListOfTypes.html#Int_t">Int_t</a>* error = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:ExecuteEvent"><span class="baseclass">TObject::</span>ExecuteEvent</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> event, <a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Fatal"><span class="baseclass">TObject::</span>Fatal</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:FillBuffer"><span class="baseclass">TNamed::</span>FillBuffer</a>(<span class="keyword">char</span>*&amp; buffer)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:FilterBandPass">FilterBandPass</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:FilterBandReject">FilterBandReject</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:FilterHighPass">FilterHighPass</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:FilterLowPass">FilterLowPass</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:FilterMovingAverage">FilterMovingAverage</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, TString mode, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:FilterMultiBand">FilterMultiBand</a>(TArray&amp; freqs, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>*</td><td class="funcname"><a class="funcname" href="#TObject:FindObject"><span class="baseclass">TObject::</span>FindObject</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>*</td><td class="funcname"><a class="funcname" href="#TObject:FindObject@1"><span class="baseclass">TObject::</span>FindObject</a>(<span class="keyword">const</span> <a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Fourier">Fourier</a>(TString mode, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:GetBandPassKernel">GetBandPassKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:GetBandRejectKernel">GetBandRejectKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:GetData">GetData</a>(TString mode) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Option_t">Option_t</a>*</td><td class="funcname"><a class="funcname" href="#TObject:GetDrawOption"><span class="baseclass">TObject::</span>GetDrawOption</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Long_t">Long_t</a></td><td class="funcname"><a class="funcname" href="#TObject:GetDtorOnly"><span class="baseclass">TObject::</span>GetDtorOnly</a>()</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:GetHighPassKernel">GetHighPassKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TObject:GetIconName"><span class="baseclass">TObject::</span>GetIconName</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:GetLowPassKernel">GetLowPassKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:GetMovingAverageKernel">GetMovingAverageKernel</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:GetMultiBandKernel">GetMultiBandKernel</a>(TArray&amp; freqs, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#NcDSP:GetN">GetN</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> mode = 0) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TNamed:GetName"><span class="baseclass">TNamed::</span>GetName</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TObject:GetObjectInfo"><span class="baseclass">TObject::</span>GetObjectInfo</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> px, <a href="./ListOfTypes.html#Int_t">Int_t</a> py) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:GetObjectStat"><span class="baseclass">TObject::</span>GetObjectStat</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Option_t">Option_t</a>*</td><td class="funcname"><a class="funcname" href="#TObject:GetOption"><span class="baseclass">TObject::</span>GetOption</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="funcname"><a class="funcname" href="#NcDSP:GetSamplingFrequency">GetSamplingFrequency</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TNamed:GetTitle"><span class="baseclass">TNamed::</span>GetTitle</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#UInt_t">UInt_t</a></td><td class="funcname"><a class="funcname" href="#TObject:GetUniqueID"><span class="baseclass">TObject::</span>GetUniqueID</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:HandleTimer"><span class="baseclass">TObject::</span>HandleTimer</a>(TTimer* timer)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Hartley">Hartley</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> mode, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#ULong_t">ULong_t</a></td><td class="funcname"><a class="funcname" href="#TNamed:Hash"><span class="baseclass">TNamed::</span>Hash</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Info"><span class="baseclass">TObject::</span>Info</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:InheritsFrom"><span class="baseclass">TObject::</span>InheritsFrom</a>(<span class="keyword">const</span> <span class="keyword">char</span>* classname) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:InheritsFrom@1"><span class="baseclass">TObject::</span>InheritsFrom</a>(<span class="keyword">const</span> TClass* cl) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Inspect"><span class="baseclass">TObject::</span>Inspect</a>() <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:InvertBit"><span class="baseclass">TObject::</span>InvertBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="func"><td class="funcret">virtual TClass*</td><td class="funcname"><a class="funcname" href="#NcDSP:IsA">IsA</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:IsEqual"><span class="baseclass">TObject::</span>IsEqual</a>(<span class="keyword">const</span> <a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>* obj) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:IsFolder"><span class="baseclass">TObject::</span>IsFolder</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:IsOnHeap"><span class="baseclass">TObject::</span>IsOnHeap</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TNamed:IsSortable"><span class="baseclass">TNamed::</span>IsSortable</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:IsZombie"><span class="baseclass">TObject::</span>IsZombie</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Load@4">Load</a>(TH1* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Load@5">Load</a>(TGraph* gr, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Load@1">Load</a>(TArray* re, TArray* im = 0, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Load@2">Load</a>(<a href="./NcSample.html">NcSample</a>* s, <a href="./ListOfTypes.html#Int_t">Int_t</a> i, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Load@3">Load</a>(<a href="./NcSample.html">NcSample</a>* s, TString name, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Load">Load</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, <a href="./ListOfTypes.html#Double_t">Double_t</a>* re, <a href="./ListOfTypes.html#Double_t">Double_t</a>* im = 0, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:LoadResult">LoadResult</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:ls"><span class="baseclass">TNamed::</span>ls</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:MayNotUse"><span class="baseclass">TObject::</span>MayNotUse</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:Notify"><span class="baseclass">TObject::</span>Notify</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Obsolete"><span class="baseclass">TObject::</span>Obsolete</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* asOfVers, <span class="keyword">const</span> <span class="keyword">char</span>* removedFromVers) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:operator_delete"><span class="baseclass">TObject::</span>operator delete</a>(<span class="keyword">void</span>* ptr)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:operator_delete@1"><span class="baseclass">TObject::</span>operator delete</a>(<span class="keyword">void</span>* ptr, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:operator_delete[]"><span class="baseclass">TObject::</span>operator delete[]</a>(<span class="keyword">void</span>* ptr)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:operator_delete[]@1"><span class="baseclass">TObject::</span>operator delete[]</a>(<span class="keyword">void</span>* ptr, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="#TObject:operator_new"><span class="baseclass">TObject::</span>operator new</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="#TObject:operator_new@1"><span class="baseclass">TObject::</span>operator new</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz, <span class="keyword">void</span>* vp)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="#TObject:operator_new[]"><span class="baseclass">TObject::</span>operator new[]</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span>*</td><td class="funcname"><a class="funcname" href="#TObject:operator_new[]@1"><span class="baseclass">TObject::</span>operator new[]</a>(<a href="./ListOfTypes.html#size_t">size_t</a> sz, <span class="keyword">void</span>* vp)</td></tr>
<tr class="func"><td class="funcret"><a href="./NcDSP.html">NcDSP</a>&amp;</td><td class="funcname"><a class="funcname" href="#NcDSP:operator_">operator=</a>(<span class="keyword">const</span> <a href="./NcDSP.html">NcDSP</a>&amp;)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Paint"><span class="baseclass">TObject::</span>Paint</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Pop"><span class="baseclass">TObject::</span>Pop</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:Print"><span class="baseclass">TNamed::</span>Print</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TObject:Read"><span class="baseclass">TObject::</span>Read</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:RecursiveRemove"><span class="baseclass">TObject::</span>RecursiveRemove</a>(<a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>* obj)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:ResetBit"><span class="baseclass">TObject::</span>ResetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:SampleAndHold@1">SampleAndHold</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ns, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> loc = -1, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmin = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmax = -1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:SampleAndHold">SampleAndHold</a>(TF1 f, <a href="./ListOfTypes.html#Double_t">Double_t</a> step, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmax, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> loc = -1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:SampleAndSum@1">SampleAndSum</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ns, TH1* hist, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmin = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmax = -1) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:SampleAndSum">SampleAndSum</a>(TF1 f, <a href="./ListOfTypes.html#Double_t">Double_t</a> step, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmax, TH1* hist = 0) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SaveAs"><span class="baseclass">TObject::</span>SaveAs</a>(<span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">""</span>, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>) <span class="keyword">const</span><span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SavePrimitive"><span class="baseclass">TObject::</span>SavePrimitive</a>(<a href="./ListOfTypes.html#ostream">ostream</a>&amp; out, <a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SetBit@1"><span class="baseclass">TObject::</span>SetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SetBit"><span class="baseclass">TObject::</span>SetBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> set)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SetDrawOption"><span class="baseclass">TObject::</span>SetDrawOption</a>(<a href="./ListOfTypes.html#Option_t">Option_t</a>* option = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SetDtorOnly"><span class="baseclass">TObject::</span>SetDtorOnly</a>(<span class="keyword">void</span>* obj)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:SetName"><span class="baseclass">TNamed::</span>SetName</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:SetNameTitle"><span class="baseclass">TNamed::</span>SetNameTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* title)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SetObjectStat"><span class="baseclass">TObject::</span>SetObjectStat</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> stat)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:SetSamplingFrequency">SetSamplingFrequency</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> f)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TNamed:SetTitle"><span class="baseclass">TNamed::</span>SetTitle</a>(<span class="keyword">const</span> <span class="keyword">char</span>* title = <span class="string">""</span>)<span class="funcprop"><abbr title="has a popup menu entry">MENU</abbr> </span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SetUniqueID"><span class="baseclass">TObject::</span>SetUniqueID</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> uid)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:SetWaveform@1">SetWaveform</a>(TArray* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:SetWaveform@4">SetWaveform</a>(TH1* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:SetWaveform@5">SetWaveform</a>(TGraph* gr, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:SetWaveform">SetWaveform</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, <a href="./ListOfTypes.html#Double_t">Double_t</a>* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:SetWaveform@2">SetWaveform</a>(<a href="./NcSample.html">NcSample</a>* s, <a href="./ListOfTypes.html#Int_t">Int_t</a> i, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:SetWaveform@3">SetWaveform</a>(<a href="./NcSample.html">NcSample</a>* s, TString name, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:ShowMembers">ShowMembers</a>(TMemberInspector&amp;)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Sine">Sine</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> type, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TNamed:Sizeof"><span class="baseclass">TNamed::</span>Sizeof</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Streamer">Streamer</a>(TBuffer&amp;)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:StreamerNVirtual">StreamerNVirtual</a>(TBuffer&amp; ClassDef_StreamerNVirtual_b)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:SysError"><span class="baseclass">TObject::</span>SysError</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TObject:TestBit"><span class="baseclass">TObject::</span>TestBit</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TObject:TestBits"><span class="baseclass">TObject::</span>TestBits</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> f) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">TArrayD</td><td class="funcname"><a class="funcname" href="#NcDSP:Transmit">Transmit</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> range, <a href="./ListOfTypes.html#Double_t">Double_t</a> Vbias = 0, TArray* Vsig = 0, TArray* peds = 0, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> B = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> C = 3) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:UseCurrentStyle"><span class="baseclass">TObject::</span>UseCurrentStyle</a>()</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:Warning"><span class="baseclass">TObject::</span>Warning</a>(<span class="keyword">const</span> <span class="keyword">char</span>* method, <span class="keyword">const</span> <span class="keyword">char</span>* msgfmt) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TObject:Write"><span class="baseclass">TObject::</span>Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TObject:Write@1"><span class="baseclass">TObject::</span>Write</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> option = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> bufsize = 0) <span class="keyword">const</span></td></tr>

</table></div>
<div class="access" id="funcprot"><b>protected:</b>
<table class="func" id="tabfuncprot" cellspacing="0">
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:DoError"><span class="baseclass">TObject::</span>DoError</a>(<span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span>* location, <span class="keyword">const</span> <span class="keyword">char</span>* fmt, va_list va) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:HistogramFilterFFT">HistogramFilterFFT</a>(TArray* h, TH1* hisf, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> kernel, TH1* hist = 0)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TObject:MakeZombie"><span class="baseclass">TObject::</span>MakeZombie</a>()</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#NcDSP:Reset">Reset</a>()</td></tr>

</table></div>
</div>

<div id="datamembers">
<h2><a name="NcDSP:Data_Members"></a>Data Members</h2>
<div class="access" id="enumpubl"><b>public:</b>
<table class="data" id="tabenumpubl" cellspacing="0">
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TObject::</span>EStatusBits { </td><td class="dataname"><a href="#TObject:kCanDelete">kCanDelete</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kMustCleanup">kMustCleanup</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kObjInCanvas">kObjInCanvas</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kIsReferenced">kIsReferenced</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kHasUUID">kHasUUID</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kCannotPick">kCannotPick</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kNoContextMenu">kNoContextMenu</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kInvalidObject">kInvalidObject</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TObject::</span><i>[unnamed]</i> { </td><td class="dataname"><a href="#TObject:kIsOnHeap">kIsOnHeap</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kNotDeleted">kNotDeleted</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kZombie">kZombie</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kBitMask">kBitMask</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kSingleKey">kSingleKey</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kOverwrite">kOverwrite</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TObject:kWriteDelete">kWriteDelete</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>

</table></div>
<div class="access" id="dataprot"><b>protected:</b>
<table class="data" id="tabdataprot" cellspacing="0">
<tr class="data"><td class="datatype">TArrayD</td><td class="dataname"><a name="NcDSP:fImIn"></a>fImIn</td><td class="datadesc">Input array for imaginary components</td></tr>
<tr class="data"><td class="datatype">TArrayD</td><td class="dataname"><a name="NcDSP:fImOut"></a>fImOut</td><td class="datadesc">Output array for imaginary components</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="dataname"><a name="NcDSP:fKeepOutput"></a>fKeepOutput</td><td class="datadesc">Internal flag to enable preventing the resetting of the output data</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="NcDSP:fN"></a>fN</td><td class="datadesc">The number of data elements to be processed as entered via Load()</td></tr>
<tr class="datainh"><td class="datatype">TString</td><td class="dataname"><a href="#TNamed:fName"><span class="baseclass">TNamed::</span>fName</a></td><td class="datadesc">object identifier</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="NcDSP:fNwf"></a>fNwf</td><td class="datadesc">The number of data elements to be processed as entered via SetWaveform();</td></tr>
<tr class="data"><td class="datatype">TVirtualFFT*</td><td class="dataname"><a name="NcDSP:fProc"></a>fProc</td><td class="datadesc">The FFTW processor</td></tr>
<tr class="data"><td class="datatype">TArrayD</td><td class="dataname"><a name="NcDSP:fReIn"></a>fReIn</td><td class="datadesc">Input array for real components</td></tr>
<tr class="data"><td class="datatype">TArrayD</td><td class="dataname"><a name="NcDSP:fReOut"></a>fReOut</td><td class="datadesc">Output array for real components</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Float_t">Float_t</a></td><td class="dataname"><a name="NcDSP:fSample"></a>fSample</td><td class="datadesc">The actual data acquisition sampling frequency in Hz</td></tr>
<tr class="datainh"><td class="datatype">TString</td><td class="dataname"><a href="#TNamed:fTitle"><span class="baseclass">TNamed::</span>fTitle</a></td><td class="datadesc">object title</td></tr>
<tr class="data"><td class="datatype">TArrayD</td><td class="dataname"><a name="NcDSP:fWaveform"></a>fWaveform</td><td class="datadesc">(System response) waveform for Convolution, Correlation etc.</td></tr>

</table></div>
</div>
<h2><a id="NcDSP:Class_Charts"></a>Class Charts</h2>
<!--INHERITANCE TREE-->
<table><tr><td width="10%"></td><td width="70%"><a href="ClassHierarchy.html">Inheritance Chart</a>:</td></tr><tr class="inhtree"><td width="10%"></td><td width="70%"><table class="inhtree"><tr><td>
<table width="100%" border="0" cellpadding ="0" cellspacing="2"><tr>
<td><table><tr>
<td bgcolor="#f7f7f7" align="right">
<tt>TNamed</tt></td>
</tr></table></td>
<td>&larr;</td><td>
<center><big><b><tt><a name="NcDSP" href="./NcDSP.html">NcDSP</a></tt></b></big></center>
</td>
<td><table><tr>
<td></td>
</tr></table></td>
</tr></table>
</td></tr></table></td></tr></table>
<h2>Function documentation</h2>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="NcDSP:NcDSP" href="src/NcDSP.cxx.html#DZVnkB">NcDSP</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span>* title = <span class="string">""</span>)</span><br />
<div class="funccomm"><pre> Default constructor.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="NcDSP:_NcDSP" href="src/NcDSP.cxx.html#l5WUaD">~NcDSP</a>()</span><br />
<div class="funccomm"><pre> Default destructor.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="NcDSP:NcDSP@1" href="src/NcDSP.cxx.html#mVc1h">NcDSP</a>(<span class="keyword">const</span> <a href="./NcDSP.html">NcDSP</a>&amp; q)</span><br />
<div class="funccomm"><pre> <a href="./#TNamed:Copy" title="void TNamed::Copy(TObject&amp; named)">Copy</a> constructor.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Reset" href="src/NcDSP.cxx.html#u7Wi8">Reset</a>()</span><br />
<div class="funccomm"><pre> Internal member function to reset all data and the FFTW processor.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:SetSamplingFrequency" href="src/NcDSP.cxx.html#sdLE.">SetSamplingFrequency</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> f)</span><br />
<div class="funccomm"><pre> Set the actual DAQ sampling frequency in Hz.
 This sampling frequency may be overwritten by invokation of
 one of the various <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions.
 The sampling frequency is set to 0 in the constructor of this class.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Float_t">Float_t</a> <a class="funcname" name="NcDSP:GetSamplingFrequency" href="src/NcDSP.cxx.html#LhiAd">GetSamplingFrequency</a>() const</span><br />
<div class="funccomm"><pre> Provide the current value of the DAQ sampling frequency in Hz.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Load" href="src/NcDSP.cxx.html#swcuJB">Load</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, <a href="./ListOfTypes.html#Double_t">Double_t</a>* re, <a href="./ListOfTypes.html#Double_t">Double_t</a>* im = 0, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Provide new input data to be processed and reset the FFTW processor.

 Note : The (optional) waveform data stored via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>() will not be modified.

 Input arguments :

 n  : The number of data elements
 re : Array with real data elements
 im : Array with imaginary data elements
 f  : (optional) Actual data acquisition sampling frequency in Hz
      In case f&lt;0 the current sampling frequency is not modified.

 If provided, the array size must be at least of dimension <span class="string">"n"</span>.

 The defaults are im=0 and f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Load@1" href="src/NcDSP.cxx.html#XFK9bB">Load</a>(TArray* re, TArray* im = 0, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Provide new input data to be processed and reset the FFTW processor.

 Note : The (optional) waveform data stored via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>() will not be modified.

 Input arguments :

 re : Array with real data elements
 im : Array with imaginary data elements
 f  : (optional) Actual data acquisition sampling frequency in Hz
      In case f&lt;0 the current sampling frequency is not modified.

 If both arrays are provided, the size of the smallest non-empty array
 will be used to compose the input data.

 The defaults are im=0 and f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Load@2" href="src/NcDSP.cxx.html#PvUWsD">Load</a>(<a href="./NcSample.html">NcSample</a>* s, <a href="./ListOfTypes.html#Int_t">Int_t</a> i, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Provide new input data from the <a href="./NcSample.html">NcSample</a> <span class="string">"s"</span> to be processed and reset the FFTW processor.

 Note : The (optional) waveform data stored via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>() will not be modified.

 Input arguments :

 i : The data of the i-th variable (1=first) of the <a href="./NcSample.html">NcSample</a> are used
 f : (optional) Actual data acquisition sampling frequency in Hz
      In case f&lt;0 the current sampling frequency is not modified.

 Note : The Store Mode of the <a href="./NcSample.html">NcSample</a> must be activated.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Load@3" href="src/NcDSP.cxx.html#otXPVE">Load</a>(<a href="./NcSample.html">NcSample</a>* s, TString name, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Provide new input data from the <a href="./NcSample.html">NcSample</a> <span class="string">"s"</span> to be processed and reset the FFTW processor.

 Note : The (optional) waveform data stored via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>() will not be modified.

 Input arguments :

 name : Name of the <a href="./NcSample.html">NcSample</a> variable of which the data are used
 f    : (optional) Actual data acquisition sampling frequency in Hz
        In case f&lt;0 the current sampling frequency is not modified.

 Note : The Store Mode of the <a href="./NcSample.html">NcSample</a> must be activated.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Load@4" href="src/NcDSP.cxx.html#RtdI4E">Load</a>(TH1* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Provide new input data from a 1-Dimensional histogram to be processed and reset the FFTW processor.

 Note : The (optional) waveform data stored via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>() will not be modified.

 Input arguments :

 h : Pointer to the 1-D histogram of which the bin contents are used
 f : (optional) Actual data acquisition sampling frequency in Hz
     In case f&lt;0 the current sampling frequency is not modified.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Load@5" href="src/NcDSP.cxx.html#t0QTjB">Load</a>(TGraph* gr, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Provide new input data from a TGraph object to be processed and reset the FFTW processor.

 Note : The (optional) waveform data stored via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>() will not be modified.

 Input arguments :

 gr : Pointer to the TGraph object of which the bin contents are used
 f  : (optional) Actual data acquisition sampling frequency in Hz
      In case f&lt;0 the current sampling frequency is not modified.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:LoadResult" href="src/NcDSP.cxx.html#uZlcs">LoadResult</a>()</span><br />
<div class="funccomm"><pre> <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a> the current transformation result as new input data in order to enable
 inverse transformations acting on previous transformation results.

 Notes :

 1) Invokation of one of the other <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() memberfunctions will reset the internal storage,
    by which previously obtained results will internally be lost.
    Use the <a href="./NcDSP.html#NcDSP:GetData" title="TArrayD NcDSP::GetData(TString mode)">GetData</a>() memberfunction to retrieve data that might be needed later again.
 2) The (optional) waveform data stored via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>() will not be modified.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:SetWaveform" href="src/NcDSP.cxx.html#Asm1MB">SetWaveform</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, <a href="./ListOfTypes.html#Double_t">Double_t</a>* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Set the (system response) waveform for Convolution, Correlation etc.

 Note : The input data stored via <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() will not be modified.

 Input arguments :

 n : The number of data elements
 h : Array with the waveform data
 f : (optional) Actual data acquisition sampling frequency in Hz
     In case f&lt;0 the current sampling frequency is not modified.

 The array size of <span class="string">"h"</span> must be at least of dimension <span class="string">"n"</span>.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:SetWaveform@1" href="src/NcDSP.cxx.html#KYYN_">SetWaveform</a>(TArray* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Set the (system response) waveform for Convolution, Correlation etc.

 Note : The input data stored via <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() will not be modified.

 Input arguments :

 h : Array with the waveform data
 f : (optional) Actual data acquisition sampling frequency in Hz
     In case f&lt;0 the current sampling frequency is not modified.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:SetWaveform@2" href="src/NcDSP.cxx.html#thmuOC">SetWaveform</a>(<a href="./NcSample.html">NcSample</a>* s, <a href="./ListOfTypes.html#Int_t">Int_t</a> i, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Set the (system response) waveform for Convolution, Correlation etc.

 Note : The input data stored via <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() will not be modified.

 Input arguments :

 s : <a href="./NcSample.html">NcSample</a> with the waveform data
 i : The data of the i-th variable (1=first) of the <a href="./NcSample.html">NcSample</a> are used
 f : (optional) Actual data acquisition sampling frequency in Hz
      In case f&lt;0 the current sampling frequency is not modified.

 Note : The Store Mode of the <a href="./NcSample.html">NcSample</a> must be activated.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:SetWaveform@3" href="src/NcDSP.cxx.html#KITCZB">SetWaveform</a>(<a href="./NcSample.html">NcSample</a>* s, TString name, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Set the (system response) waveform for Convolution, Correlation etc.

 Note : The input data stored via <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() will not be modified.

 Input arguments :

 s    : <a href="./NcSample.html">NcSample</a> with the waveform data
 name : Name of the <a href="./NcSample.html">NcSample</a> variable of which the data are used
 f    : (optional) Actual data acquisition sampling frequency in Hz
        In case f&lt;0 the current sampling frequency is not modified.

 Note : The Store Mode of the <a href="./NcSample.html">NcSample</a> must be activated.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:SetWaveform@4" href="src/NcDSP.cxx.html#X.VzCB">SetWaveform</a>(TH1* h, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Set the (system response) waveform for Convolution, Correlation etc.

 Note : The input data stored via <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() will not be modified.

 Input arguments :

 h : Pointer to the 1-D histogram of which the bin contents are used for the waveform data
 f : (optional) Actual data acquisition sampling frequency in Hz
     In case f&lt;0 the current sampling frequency is not modified.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:SetWaveform@5" href="src/NcDSP.cxx.html#qCF1wD">SetWaveform</a>(TGraph* gr, <a href="./ListOfTypes.html#Float_t">Float_t</a> f = -1)</span><br />
<div class="funccomm"><pre> Set the (system response) waveform for Convolution, Correlation etc.

 Note : The input data stored via <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() will not be modified.

 Input arguments :

 gr : Pointer to the TGraph object of which the bin contents are used for the waveform data
 f  : (optional) Actual data acquisition sampling frequency in Hz
      In case f&lt;0 the current sampling frequency is not modified.

 The default value is f=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="NcDSP:GetN" href="src/NcDSP.cxx.html#HwicvD">GetN</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> mode = 0) const</span><br />
<div class="funccomm"><pre> Provide the number of data elements (to be) processed.

 mode : 0 --&gt; Provide the number of input data elements entered via <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>()
        1 --&gt; Provide the number of input data elements entered via <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>()

 The default value is mode=0 for backward compatibility.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:GetData" href="src/NcDSP.cxx.html#qrqDkE">GetData</a>(TString mode) const</span><br />
<div class="funccomm"><pre> Provide a selected set of data.

 Input argument :

 sel  : String to specify the contents of the provided data array
        <span class="string">"RE"</span>   --&gt; The values of the real (re) components
        <span class="string">"IM"</span>   --&gt; The values of the imaginary (im) components
        <span class="string">"AMP"</span>  --&gt; The amplitudes, i.e. sqrt(re*re+im*im)
        <span class="string">"PHIR"</span> --&gt; The phases, i.e. arctan(im/re), in radians
        <span class="string">"PHID"</span> --&gt; The phases, i.e. arctan(im/re), in degrees
        <span class="string">"in"</span>   --&gt; The values of the input data are provided
        <span class="string">"out"</span>  --&gt; The values of the output data are provided
        <span class="string">"Wave"</span> --&gt; The values of the stored (system response) waveform data are provided

 Examples :

 sel=<span class="string">"AMP out"</span> will provide all the N amplitudes of the resulting data after transformation.
 sel=<span class="string">"RE in"</span> will provide all the N real components of the input data.
 sel=<span class="string">"Wave"</span> will provide all the amplitudes of the stored (system response) waveform
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Fourier" href="src/NcDSP.cxx.html#P579wE">Fourier</a>(TString mode, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</span><br />
<div class="funccomm"><pre> Perform a normalized 1-dimensional Discrete <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> Transformation (DFT).

 Conventions :

 N = The number of data elements
 Time domain array : X[]=X[0],...,X[N-1]
 Frequency domain array : Q[]=Q[0],...,Q[N-1]

 <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform : Q[k]=(1/sqrt(N))*sum(n=0,n=N-1){X[n]*exp(-i*2pi*(k/N)*n)}

 Inverse <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform : X[n]=(1/sqrt(N))*sum(k=0,k=N-1){Q[k]*exp(i*2pi*(n/N)*k)}

 Input arguments :

 mode : <span class="string">"R2C"</span>  --&gt; Perform a real-input to complex-output discrete <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transformation
        <span class="string">"C2R"</span>  --&gt; Perform the inverse transformation of <span class="string">"R2C"</span>
        <span class="string">"C2C"</span>  --&gt; Perform a complex-input to complex-output discrete <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transformation
        <span class="string">"C2CI"</span> --&gt; Perform the inverse of <span class="string">"C2C"</span>
 hist : (optional) Histogram with selected results
 sel  : String to specify the contents and representation of the result histogram
        <span class="string">"RE"</span>   --&gt; Y-axis shows the values of the real (re) components
        <span class="string">"IM"</span>   --&gt; Y-axis shows the values of the imaginary (im) components
        <span class="string">"AMP"</span>  --&gt; Y-axis shows the values of the amplitudes, i.e. sqrt(re*re+im*im)
        <span class="string">"dB"</span>   --&gt; Y-axis shows the values of the amplitudes, i.e. sqrt(re*re+im*im), in decibel
        <span class="string">"PHIR"</span> --&gt; Y-axis shows the values of the phases, i.e. arctan(im/re), in radians
        <span class="string">"PHID"</span> --&gt; Y-axis shows the values of the phases, i.e. arctan(im/re), in degrees
        <span class="string">"k"</span>    --&gt; X-axis represents the index k in the frequency domain
        <span class="string">"f"</span>    --&gt; X-axis represents the fraction f of the sampling rate in the frequency domain
        <span class="string">"Hz"</span>   --&gt; X-axis represents the actual frequency in Hz in the frequency domain
        <span class="string">"n"</span>    --&gt; X-axis represents the index n in the time domain
        <span class="string">"t"</span>    --&gt; X-axis represents the actual time in seconds in the time domain
        <span class="string">"2"</span>    --&gt; X-axis spans the full number of data points, instead of the usual (N/2)+1

 Note : The options <span class="string">"Hz"</span> and <span class="string">"t"</span> can only be used if the actual data acquisition sampling rate
        has been provided via the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() memberfunction.

 Examples :

 sel=<span class="string">"AMP f"</span>  will show the (N/2)+1 amplitudes as a function of the fractional sampling rate.
 sel=<span class="string">"dB f"</span>   will show the (N/2)+1 amplitudes in dB as a function of the fractional sampling rate.
 sel=<span class="string">"RE k 2"</span> will show all N real components as a function of the index k in the frequency domain.

 The default values are hist=0 and sel=<span class="string">"none"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Hartley" href="src/NcDSP.cxx.html#Jm6K.D">Hartley</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> mode, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</span><br />
<div class="funccomm"><pre> Perform a normalized 1-dimensional Discrete <a href="./NcDSP.html#NcDSP:Hartley" title="void NcDSP::Hartley(Int_t mode,TH1* hist=0,TString sel=&quot;none&quot;)">Hartley</a> Transformation (DHT).
 Actually, a DHT is closely related to a Discrete <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> Transformation (DFT)
 with only real input values.
 Consequently, the resulting transformed array is also only real.

 Indicating in the frequency domain the DHT data elements by H[k] and the
 DFT data elements by F[k], we have the following relations :

 1) Re(F[k])=(H[k]+H[N-k])/2 and Im(F[k])=(H[N-k]-H[k])/2
 2) H[k]=Re((1+i)*F[k])

 Conventions :

 N = The number of data elements
 Time domain array : X[]=X[0],...,X[N-1]
 Frequency domain array : Q[]=Q[0],...,Q[N-1]

 <a href="./NcDSP.html#NcDSP:Hartley" title="void NcDSP::Hartley(Int_t mode,TH1* hist=0,TString sel=&quot;none&quot;)">Hartley</a> transform : Q[k]=(1/sqrt(N))*sum(n=0,n=N-1){X[n]*[cos(2pi*(k/N)*n)+sin(2pi*(k/N)*n)]}

 Inverse <a href="./NcDSP.html#NcDSP:Hartley" title="void NcDSP::Hartley(Int_t mode,TH1* hist=0,TString sel=&quot;none&quot;)">Hartley</a> transform : X[n]=(1/sqrt(N))*sum(n=0,k=N-1){Q[k]*[cos(2pi*(n/N)*k)+sin(2pi*(n/N)*k)]}

 So, it is seen that the <a href="./NcDSP.html#NcDSP:Hartley" title="void NcDSP::Hartley(Int_t mode,TH1* hist=0,TString sel=&quot;none&quot;)">Hartley</a> transform is its own inverse.

 Input arguments :

 mode : &gt;0     --&gt; Perform the forward X[n]-&gt;Q[k] <a href="./NcDSP.html#NcDSP:Hartley" title="void NcDSP::Hartley(Int_t mode,TH1* hist=0,TString sel=&quot;none&quot;)">Hartley</a> transformation
        &lt;0     --&gt; Perform the backward Q[k]-&gt;X[n] <a href="./NcDSP.html#NcDSP:Hartley" title="void NcDSP::Hartley(Int_t mode,TH1* hist=0,TString sel=&quot;none&quot;)">Hartley</a> transformation
 hist : (optional) Histogram with selected results
 sel  : String to specify the representation of the result histogram
        <span class="string">"k"</span>    --&gt; X-axis represents the index k in the frequency domain
        <span class="string">"f"</span>    --&gt; X-axis represents the fraction f of the sampling rate in the frequency domain
        <span class="string">"Hz"</span>   --&gt; X-axis represents the actual frequency in Hz in the frequency domain
        <span class="string">"n"</span>    --&gt; X-axis represents the index n in the time domain
        <span class="string">"t"</span>    --&gt; X-axis represents the actual time in seconds in the time domain
        <span class="string">"2"</span>    --&gt; X-axis spans the full number of data points, instead of the usual (N/2)+1

 Note : The options <span class="string">"Hz"</span> and <span class="string">"t"</span> can only be used if the actual data acquisition sampling rate
        has been provided via the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() memberfunction.

 Examples :

 sel=<span class="string">"f"</span> will show the (N/2)+1 amplitudes as a function of the fractional sampling rate.
 sel=<span class="string">"k 2"</span> will show all N amplitudes as a function of the index k in the frequency domain.

 The default values are hist=0 and sel=<span class="string">"none"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Cosine" href="src/NcDSP.cxx.html#Xjw6AC">Cosine</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> type, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</span><br />
<div class="funccomm"><pre> Perform a normalized 1-dimensional Discrete <a href="./NcDSP.html#NcDSP:Cosine" title="void NcDSP::Cosine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Cosine</a> Transformation (DCT).
 Actually, this is just a regular Discrete <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> Transformation (DFT)
 with only real input values which contain an even symmetry.
 Consequently, the resulting transformed array is also only real with even symmetry.

 Conventions :

 N = The number of data elements
 Time domain array : X[]=X[0],...,X[N-1]
 Frequency domain array : Q[]=Q[0],...,Q[N-1]

 <a href="./NcDSP.html#NcDSP:Cosine" title="void NcDSP::Cosine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Cosine</a> transform type 1 : Q[k]=(1/sqrt(2*(N-1)))*[X[0]+pow(-1,k)*X[N-1]+2*sum(n=1,n=N-2){X[n]*cos(pi*n*k/(N-1))}]

 <a href="./NcDSP.html#NcDSP:Cosine" title="void NcDSP::Cosine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Cosine</a> transform type 2 : Q[k]=(1/sqrt(2N))*2*sum(n=0,n=N-1){X[n]*cos(pi*(n+1)*k/N)}]

 <a href="./NcDSP.html#NcDSP:Cosine" title="void NcDSP::Cosine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Cosine</a> transform type 3 : Q[k]=(1/sqrt(2N))[X[0]+2*sum(n=0,n=N-1){X[n]*cos(pi*n*(k+0.5)/N)}]

 <a href="./NcDSP.html#NcDSP:Cosine" title="void NcDSP::Cosine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Cosine</a> transform type 4 : Q[k]=(1/sqrt(2N))*2*sum(n=0,n=N-1){X[n]*cos(pi*(n+0.5)*(k+0.5)/N)}

 Notes :

 1) The type 1 transformation is only defined for N&gt;1 and is its own inverse.
 2) The type 4 transformation is its own inverse.
 3) The type 3 transformation is the inverse of type 2 (and vice versa).
 4) The type 2 transformation is often called <span class="string">"the"</span> DCT.
 5) The type 3 transformation id often called <span class="string">"the"</span> inverse DCT (IDCT).

 Input arguments :

 type : The type of transformation (i.e. 1,2,3 or 4) to be performed
        The inverse transformations are specified with the corresponding negative type value
 hist : (optional) Histogram with selected results
 sel  : String to specify the representation of the result histogram
        <span class="string">"k"</span>    --&gt; X-axis represents the index k in the frequency domain
        <span class="string">"f"</span>    --&gt; X-axis represents the fraction f of the sampling rate in the frequency domain
        <span class="string">"Hz"</span>   --&gt; X-axis represents the actual frequency in Hz in the frequency domain
        <span class="string">"n"</span>    --&gt; X-axis represents the index n in the time domain
        <span class="string">"t"</span>    --&gt; X-axis represents the actual time in seconds in the time domain
        <span class="string">"2"</span>    --&gt; X-axis spans the full number of data points, instead of the usual (N/2)+1

 Note : The options <span class="string">"Hz"</span> and <span class="string">"t"</span> can only be used if the actual data acquisition sampling rate
        has been provided via the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() memberfunction.

 Examples :

 sel=<span class="string">"f"</span> will show the (N/2)+1 amplitudes as a function of the fractional sampling rate.
 sel=<span class="string">"k 2"</span> will show all N amplitudes as a function of the index k in the frequency domain.

 The default values are hist=0 and sel=<span class="string">"none"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:Sine" href="src/NcDSP.cxx.html#dZEkaB">Sine</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> type, TH1* hist = 0, TString sel = <span class="string">"none"</span>)</span><br />
<div class="funccomm"><pre> Perform a normalized 1-dimensional Discrete <a href="./NcDSP.html#NcDSP:Sine" title="void NcDSP::Sine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Sine</a> Transformation (DST).
 Actually, this is just a regular Discrete <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> Transformation (DFT)
 with only real input values which contain an odd symmetry.
 Consequently, the resulting transformed array is also only real with odd symmetry.

 Conventions :

 N = The number of data elements
 Time domain array : X[]=X[0],...,X[N-1]
 Frequency domain array : Q[]=Q[0],...,Q[N-1]

 <a href="./NcDSP.html#NcDSP:Sine" title="void NcDSP::Sine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Sine</a> transform type 1 : Q[k]=(1/sqrt(2N+1))*2*sum(n=0,n=N-1){X[n]*sin(pi*(n+1)*(k+1)/(N+1))}]

 <a href="./NcDSP.html#NcDSP:Sine" title="void NcDSP::Sine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Sine</a> transform type 2 : Q[k]=(1/sqrt(2N))*2*sum(n=0,n=N-1){X[n]*sin(pi*(n+0.5)*(k+1)/N)}

 <a href="./NcDSP.html#NcDSP:Sine" title="void NcDSP::Sine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Sine</a> transform type 3 : Q[k]=(1/sqrt(2N))*[pow(-1,k)*X[N-1]+2*sum(n=0,n=N-2){X[n]*sin(pi*(n+1)*(k+0.5)/N)}]

 <a href="./NcDSP.html#NcDSP:Sine" title="void NcDSP::Sine(Int_t type,TH1* hist=0,TString sel=&quot;none&quot;)">Sine</a> transform type 4 : Q[k]=(1/sqrt(2N))*2*sum(n=0,n=N-1){X[n]*sin(pi*(n+0.5)*(k+0.5)/N)}

 Notes :

 1) The type 1 transformation is its own inverse.
 2) The type 4 transformation is its own inverse.
 3) The type 3 transformation is the inverse of type 2 (and vice versa).

 Input arguments :

 type : The type of transformation (i.e. 1,2,3 or 4) to be performed
        The inverse transformations are specified with the corresponding negative type value
 hist : (optional) Histogram with selected results
 sel  : String to specify the representation of the result histogram
        <span class="string">"k"</span>    --&gt; X-axis represents the index k in the frequency domain
        <span class="string">"f"</span>    --&gt; X-axis represents the fraction f of the sampling rate in the frequency domain
        <span class="string">"Hz"</span>   --&gt; X-axis represents the actual frequency in Hz in the frequency domain
        <span class="string">"n"</span>    --&gt; X-axis represents the index n in the time domain
        <span class="string">"t"</span>    --&gt; X-axis represents the actual time in seconds in the time domain
        <span class="string">"2"</span>    --&gt; X-axis spans the full number of data points, instead of the usual (N/2)+1

 Note : The options <span class="string">"Hz"</span> and <span class="string">"t"</span> can only be used if the actual data acquisition sampling rate
        has been provided via the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() memberfunction.

 Examples :

 sel=<span class="string">"f"</span> will show the (N/2)+1 amplitudes as a function of the fractional sampling rate.
 sel=<span class="string">"k 2"</span> will show all N amplitudes as a function of the index k in the frequency domain.

 The default values are hist=0 and sel=<span class="string">"none"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:Convolve" href="src/NcDSP.cxx.html#AKCM1B">Convolve</a>(TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> shift = 0)</span><br />
<div class="funccomm"><pre> <a href="./NcDSP.html#NcDSP:Convolve" title="TArrayD NcDSP::Convolve(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Int_t shift=0)">Convolve</a> the loaded input data x[] with the data contained in the (system response)
 waveform h[] and return the resulting data y[] in a TArrayD object.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions,
 whereas the (system response) waveform h[] has to be specified by <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>().
 The provided data of x[] and h[] are not modified.

 In formula : y[]=x[]*h[].

 The convolution of two (time) series expresses how the shape of one
 is modified by the other, which makes it a versatile tool to describe
 system responses, digital filtering processing, superposition of various influences
 in physical systems etc.
 The result y[] can be regarded as the weighted sum (or pdf) of X+H, where
 X and H are two independent random variables with as pdf x[] and h[], respectively.
 Note that here x[]*h[] is identical to h[]*x[].

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 hist : (optional) Histogram with the convolution result

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting convolved data array for which <span class="string">"h"</span> was fully immersed in the
 input (signal) data x[].
 In other words : The indices range [i1,i2] in the resulting convolved data array y[]
 corresponds to all the y[] elements for which the convolution was completely performed
 by using all the elements of h[].
 So, values of y[j] with j&lt;i1 or j&gt;i2 contain incomplete convolutions, and as such should not
 be considered as reliable, especially when x[] and/or h[] contain large variations.

 The argument <span class="string">"shift"</span> determines whether the Xaxis values of the (optional) result histogram
 are shifted or that the array y[] is truncated in order to provide (a view of) the resulting array y[]
 such that it can be directly compared to the original array x[] (see notes 2) and 3) below).

 The convention is :
 shift = 0 --&gt; No shift and the full array y[] is returned and shown <span class="string">"as is"</span> in the (optional) histogram.
         1 --&gt; The full array y[] is returned and shown in the (optional) histogram with y[i1] at the center.
               This mode is particulary useful for correlation studies between two distributions [see <a href="./NcDSP.html#NcDSP:Correlate" title="TArrayD NcDSP::Correlate(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Double_t* peak=0)">Correlate</a>()],
               since it will show both negative and positive values at the Xaxis of the (optional) histogram,
               and the self-correlation peak coincides with the value 0 at the Xaxis.
         2 --&gt; The array y[] contains only the modified x[] elements and is shown with y[0] at the start of the (optional) histogram.
               This mode is particulary useful for digital filtering processes (see the various filtering member functions),
               since it allows to directly compare the filtered and the unfiltered x[] distribution.

 Notes :

 1) The sampling (rate) of h[] has to be the same as for the input data x[].
 2) Array sizes of x[nx] and h[nh] will result in a convolved data array of size y[(nx+nh-1)],
    except for shift=2 for which the convolved data array has size y[nx].
 3) For an absolute comparison between the x[] and y[] values, one should realize that
    the array sizes of x[] and y[] are different and that x[k] should be compared with y[k+i1].
 4) The values i1 and i2 (if requested) are indicated by vertical dashed blue lines
    in the time domain histogram.

 The default values are hist=0, i1=0, i2=0 and shift=0.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:Correlate" href="src/NcDSP.cxx.html#AeWPv">Correlate</a>(TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a>* peak = 0)</span><br />
<div class="funccomm"><pre> (Cross) <a href="./NcDSP.html#NcDSP:Correlate" title="TArrayD NcDSP::Correlate(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Double_t* peak=0)">Correlate</a> the data contained in the waveform h[] with the loaded input data x[]
 and return the resulting data y[] in a TArrayD object.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions,
 whereas the waveform h[] has to be specified by <a href="./NcDSP.html#NcDSP:SetWaveform" title="void NcDSP::SetWaveform(Int_t n,Double_t* h,Float_t f=-1) or overloads">SetWaveform</a>().
 The provided data of x[] and h[] are not modified.

 In formula : y[]=h[]*x[].

 The cross-correlation is a measure of similarity of two (time) series as a function
 of the displacement of one relative to the other.
 The result y[] can be regarded as the weighted sum (or pdf) of X-H, where
 X and H are two independent random variables with as pdf x[] and h[], respectively.
 Note that here h[]*x[] is different from x[]*h[].

 Mathematically it is seen that the cross-correlation h[]*x[] is equivalent
 to the convolution of h[] and x[], but with the ordering of the elements
 of the distribution h[] reversed.

 In formula : Cross-correlation h[m]*x[n] is equivalent to Convolution h[-m]*x[n].

 This feature is used here to centralize the computation in the member function <a href="./NcDSP.html#NcDSP:Convolve" title="TArrayD NcDSP::Convolve(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Int_t shift=0)">Convolve</a>(),
 so that also this <a href="./NcDSP.html#NcDSP:Correlate" title="TArrayD NcDSP::Correlate(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Double_t* peak=0)">Correlate</a>() processor will automatically profit from possible CPU speed
 improvements in the Convolution processor.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 hist : (optional) Histogram with the correlation result

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting correlated data array for which <span class="string">"h"</span> was fully immersed in the
 input (signal) data.
 These values i1 and i2 (if requested) are indicated by vertical
 dashed blue lines in the histogram.

 The (optional) argument <span class="string">"peak"</span> provides the location of the correlation peak, indicating
 the shift of the h[] pattern w.r.t. the best matching pattern in x[], with the convention
 that the autocorrelation peak falls at 0.

 Note : The sampling (rate) of h has to be the same as for the loaded input data x[].

 The default values are hist=0, i1=0, i2=0 and peak=0.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:Digitize" href="src/NcDSP.cxx.html#zpJppE">Digitize</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> vcal, <a href="./ListOfTypes.html#Int_t">Int_t</a> mode, TH1* hist = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a>* stp = 0, <a href="./ListOfTypes.html#Double_t">Double_t</a>* scale = 0) const</span><br />
<div class="funccomm"><pre>
 *** This function has become obsolete and is only kept for backward compatibility. ***
 *** Please refer to the new, more flexible memberfunction <a href="./NcDSP.html#NcDSP:Transmit" title="TArrayD NcDSP::Transmit(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">Transmit</a>().              ***
 *** The user can also invoke the <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> and <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> processors individually by means of   ***
 *** the corresponding memberfunctions <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>() and <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>().                             ***


 <a href="./NcDSP.html#NcDSP:Digitize" title="TArrayD NcDSP::Digitize(Int_t nbits,Double_t vcal,Int_t mode,TH1* hist=0,Double_t* stp=0,Double_t* scale=0)">Digitize</a> the values of the stored waveform according to an <span class="string">"nbits"</span> <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
 The resulting digitized values are returned in a TArrayD object,
 without modification of the original waveform data.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 nbits &gt;0 : Digitization of the values will be performed using nbits.
       &lt;0 : Digitization of the Log10 of the values will be performed using |nbits|.
            After digitization of the Log10 value, the digitized result (digval) is
            used to store the corresponding linear value via value=pow(10,digval).
            So, nbits&lt;0 emulates a Log10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> to enhance the dynamic range.
            Note : When nbits&lt;0 all values to be digitized should be positive.
 vcal     : Range calibration value of the <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> according to <span class="string">"mode"</span> as indicated below.
 mode  =0 : Range for the digitized result (digval) will be set to [0,vcal] (or [vcal,0] if vcal&lt;0).
        1 : Full scale range for the digitized result (digval) will be set to [-|vcal|,|vcal|].
        2 : A step size of |vcal| is used providing a digval interval of [0,scale] (or [-scale,0] if vcal&lt;0).
        3 : A step size of |vcal| is used providing a digval interval of [-scale,scale].

 Optional output arguments :

 hist  : Histogram with the digitized result
 stp   : The value of <span class="string">"step size"</span>.
 scale : The value of <span class="string">"scale"</span>.

 Notes :

 1) The step size corresponds closely to the Least Significant Bit (LSB) precision for the
    digitized result (digval).
    For an n-bit <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> we have stepsize=range/(-1+2^n), whereas LSB=1/(2^n).
 2) In case of a Log10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>, the value of <span class="string">"vcal"</span> relates to the Log10 values.
    So, for a Log10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>, the <span class="string">"vcal"</span> interval [-2,2] represents linear values [0.01,100].
    A step size of 0.0315 for an 8-bit Log10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> provides a Log10 interval of [-4,4]
    for mode=3, which corresponds to a linear value interval of [0.0001,10000].
    For mode=2 this would result in a Log10 interval of [0,8.0325], which corresponds
    to a linear value interval of [1,1.0777e8].
    A step size of 0.01 between the Log10 values corresponds to a multiplication factor
    of 10^0.01 (i.e. about 1.023) for the linear values at each step.
 3) In case no waveform is present, just the specs of the specified <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> performance will be printed,
    but no digitization is performed.
    This allows to quickly investigate various scenarios without any data treatment.

 The maximum number of bits that is supported is 60 to guarantee identical functioning
 on all machines.

 In case of inconsistent input parameters, no digitization is performed and an empty TArrayD is returned.

 The default values are hist=0, stp=0 and scale=0.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayL64 <a class="funcname" name="NcDSP:ADC" href="src/NcDSP.cxx.html#JDoIR">ADC</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> range, <a href="./ListOfTypes.html#Double_t">Double_t</a> Vbias = 0, TArray* Vsig = 0, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> B = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> C = 3) const</span><br />
<div class="funccomm"><pre> Processing of an Analog to Digital Converter (<a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>).
 Construct from analog input signals the discrete quantized data values of an <span class="string">"nbits"</span> <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>,
 based on the <span class="string">"range"</span> for the analog signal and a bias voltage <span class="string">"Vbias"</span> (see below).
 The analog input signals may be provided by the (optional) TArray <span class="string">"Vsig"</span>.
 In case the array <span class="string">"Vsig"</span> is not provided, the stored waveform is used to provide the analog input signals.
 The resulting (integer) quantized <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> values are returned in a TArrayL64 object,
 without modification of the original waveform data.

 Note : Make sure to use the same units for <span class="string">"range"</span>, <span class="string">"Vbias"</span> and the analog input signals.

 The number of available quantization levels is given by N=2^|nbits|, of which the lowest
 level represents the value 0. This yields for the quantized values (adc) the range [0,N-1].
 The mapping of an analog input voltage (Vin) to one of the quantization levels depends on the
 specified <span class="string">"range"</span> and <span class="string">"Vbias"</span> and whether we have a linear or Log <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> (see below).

 As outlined below, the range of the analog input voltage can be specified as the Full Scale
 voltage range (Vfs) corresponding to adc=N-1 or as the Reference voltage (Vref) corresponding to
 the hypothetical adc=N.

 The Least Significant Bit (LSB) represents the smallest analog input voltage interval
 that can reliably be resolved. In other words LSB=Voltage(adc=1)-Voltage(adc=0).
 For a linear <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> we have : LSB=Vfs/(N-1) or equivalently LSB=Vref/N.
 For a Log_B <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> (see below) we have : LSB=Vref*pow(B,-C)*(pow(B,C/N)-1).

 The formulas for the Vin-&gt;adc mapping with Vin=(Vbias+Vsig) are :
 Linear <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> : adc=Vin/LSB.
 Log_B <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> (see below) : adc=(N/C)*Log_B(pow(B,C)*Vin/Vref).

 Which leads to the following relations between Vref and Vfs :
 Linear <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> : Vref=Vfs+LSB.
 Log_B <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> (see below) : Vfs=Vref*pow(B,-C)*pow(B,(N-1)*C/N).

 The Dynamic Range (DR) is defined as the ratio of the largest and smallest input voltages
 that can reliably be resolved.
 Expressed in decibel we have : DR=20*log_10(Vfs/LSB) dB.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 and the publication by Y. Sundarasaradula et al. :
 <span class="string">"A 6-bit, Two-step, Successive Approximation Logarithmic ADC for Biomedical Applications"</span>
 which is online available at https://spiral.imperial.ac.uk/bitstream/10044/1/44156/2/2016_ICECS_LogADC_Camera.pdf.

 Input arguments :

 nbits    : Digital quantization of the input values will be performed using nbits.
 range &gt;0 : The full scale voltage range (Vfs) of the analog signal that corresponds to adc=N-1.
       &lt;0 : |range| is the reference voltage (Vref) of the analog signal that corresponds to the hypothetical adc=N.
 Vbias    : The bias voltage that will be added to the analog input signal before digitization.
 Vsig     : (Optional) array to contain the analog input signals.
 B     &gt;1 : Base for a Log <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> (e.g. B=10 emulates a Log_10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>).
       =0 : The <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> will be linear
       =1 : The <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> will be a Log_e <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
            Note : When B&gt;0 all (Vbias+Vsig) input values should be positive.
 C        : Code efficiency factor for a Log <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
            Rule of thumb : pow(B,-C) is about the smallest signal/|range| ratio that can be resolved.
            So, for a log_10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> with C=3, the smallest signal that can be resolved is about |range|/1000.
            Note : It is required that C&gt;0.

 Optional output arguments :

 hist  : Histogram with the digitized result

 Notes :

 1) In case no <span class="string">"Vsig"</span> array is provided and no waveform is present, just the <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> specs will be printed
    and in the TArrayL64 only the adc value corresponding to Vbias is returned.
    This allows to quickly investigate various scenarios without any data treatment.
 2) Providing a <span class="string">"Vsig"</span> array with different small (random) amplitudes allows to mimic variations of the bias or
    characteristics of the various switched capacitor array elements for the individual samplings.
    This resembles a so called <span class="string">"pedestal run"</span> in real life Data Acquisition (DAQ) applications.
    For a linear <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>, the contents of the returned TArrayL64 can be used afterwards for pedestal subtraction.

 The maximum number of bits that is supported is 60 to guarantee identical functioning
 on all machines.

 In case of inconsistent input parameters, no digitization is performed and an empty TArrayL64 is returned.

 The default values are Vbias=0, Vsig=0, hist=0, B=0 and C=3.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:DAC" href="src/NcDSP.cxx.html#uy4VWB">DAC</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> range, <a href="./ListOfTypes.html#Double_t">Double_t</a> Vbias = 0, TArray* adcs = 0, TArray* peds = 0, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> B = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> C = 3) const</span><br />
<div class="funccomm"><pre> Processing of a Digital to Analog Converter (<a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>).
 Reconstruct the analog signals based on the discrete quantized digital data from an <span class="string">"nbits"</span> <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>,
 based on the <span class="string">"range"</span> for the analog signal and a bias voltage <span class="string">"Vbias"</span> or array <span class="string">"peds"</span> of pedestal values (see below).
 The digital input signals may be provided by the (optional) TArray <span class="string">"adcs"</span>.
 In case the array <span class="string">"adcs"</span> is not provided, the stored waveform is used to provide the digital input signals.
 The resulting analog values are returned in a TArrayD object, without modification of the original waveform data.

 Note : Make sure to use the same units for <span class="string">"range"</span> and <span class="string">"Vbias"</span>.

 The number of digital quantization levels is given by N=2^|nbits|, of which the lowest
 level represents the value 0. This implies a range [0,N-1] for the various digital adc values.
 The correspondance of an analog input voltage (Vin) to one of the quantization levels depends on the
 specified <span class="string">"range"</span> and <span class="string">"Vbias"</span> and whether we have a linear or Log <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> (see below).

 As outlined below, the range of the analog input voltage can be specified as the Full Scale
 voltage range (Vfs) corresponding to adc=N-1 or as the Reference voltage (Vref) corresponding to
 the hypothetical adc=N.

 The Least Significant Bit (LSB) represents the smallest analog input voltage interval
 that can reliably be resolved. In other words LSB=Voltage(adc=1)-Voltage(adc=0).
 For a linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> we have : LSB=Vfs/(N-1) or equivalently LSB=Vref/N.
 For a Log_B <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> (see below) we have : LSB=Vref*pow(B,-C)*(pow(B,C/N)-1).

 The formulas for the adc-&gt;Vin mapping with Vin=(Vbias+Vsig) are :
 Linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> : Vin=adc*LSB.
 Log_B <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> (see below) : Vin=Vref*pow(B,-C)*pow(B,C*adc/N)

 Which implies the following relations between Vref and Vfs :
 Linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> : Vref=Vfs+LSB.
 Log_B <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> (see below) : Vfs=Vref*pow(B,-C)*pow(B,C*(N-1)/N).

 The Dynamic Range (DR) is defined as the ratio of the largest and smallest analog voltages
 that can reliably be resolved.
 Expressed in decibel we have : DR=20*log_10(Vfs/LSB) dB.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 and the publication by Y. Sundarasaradula et al. :
 <span class="string">"A 6-bit, Two-step, Successive Approximation Logarithmic ADC for Biomedical Applications"</span>
 which is online available at https://spiral.imperial.ac.uk/bitstream/10044/1/44156/2/2016_ICECS_LogADC_Camera.pdf.

 Input arguments :

 nbits    : Digitial quantization was performed using an nbits <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
 range &gt;0 : The full scale voltage range (Vfs) of the analog signal that corresponds to adc=N-1.
       &lt;0 : |range| is the reference voltage (Vref) of the analog signal that corresponds to the hypothetical adc=N.
 Vbias    : The bias voltage that was added to the analog input signal before digitization.
            If specified, the resulting analog signals will be corrected for the bias voltage.
            For a linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> the correction via Vbias will only be performed if no pedestal array <span class="string">"peds"</span>
            is specified (see below). If the array <span class="string">"peds"</span> is specified, Vbias will be ignored for a linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>.
            For a Log <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> the pedestal values will never be used and bias correction may only be obtained via Vbias.
 adcs     : (Optional) array to contain the digital input signals.
 peds     : (Optional) array to contain the pedestal values for the individual digital input signals.
            The array <span class="string">"peds"</span> must contain (at least) the same number of values as the number of digital input signals.
            If the array <span class="string">"peds"</span> is specified, the pedestals will be subtracted from the corresponding digital input signals
            before the conversion to analog signals is performed in case of a linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>.
            For a Log <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> the pedestal values will never be used and bias correction may only be obtained via Vbias.
 B     &gt;1 : Base for a Log <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> (e.g. B=10 emulates a Log_10 <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>).
       =0 : The <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> will be linear
       =1 : The <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> will be a Log_e <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>.
 C        : Code efficiency factor that was used for a Log <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
            Rule of thumb : pow(B,-C) is about the smallest signal/|range| ratio that can be resolved.
            So, for a Log_10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> with C=3, the smallest signal that can be resolved is about |range|/1000.
            Note : It is required that C&gt;0.

 Optional output arguments :

 hist  : Histogram with the analog result

 Notes :

 1) In case no <span class="string">"adcs"</span> array is provided and no waveform is present, just the <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> specs will be printed
    and in the TArrayD only the adc value corresponding to Vbias is returned.
    This allows to quickly investigate various scenarios without any data treatment.

 The maximum number of bits that is supported is 60 to guarantee identical functioning
 on all machines.

 In case of inconsistent input parameters, no processing is performed and an empty TArrayD is returned.

 The default values are Vbias=0, adcs=0, peds=0, hist=0, B=0 and C=3.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:Transmit" href="src/NcDSP.cxx.html#vRLgkB">Transmit</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> nbits, <a href="./ListOfTypes.html#Double_t">Double_t</a> range, <a href="./ListOfTypes.html#Double_t">Double_t</a> Vbias = 0, TArray* Vsig = 0, TArray* peds = 0, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> B = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> C = 3) const</span><br />
<div class="funccomm"><pre> Mimic signal transmission according to an <span class="string">"nbits"</span> <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>-<a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> chain.
 Analog input signals are digitized via the discrete quantization levels of an <span class="string">"nbits"</span> <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>,
 based on the <span class="string">"range"</span> for the analog signal and a bias voltage <span class="string">"Vbias"</span> or array <span class="string">"peds"</span> of pedestal values (see below).
 The analog input signals may be provided by the (optional) TArray <span class="string">"Vsig"</span>.
 In case the array <span class="string">"Vsig"</span> is not provided, the stored waveform is used to provide the analog input signals.
 After digitization, the digital signals are converted into analog signals via the corresponding <span class="string">"nbits"</span> <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>.
 In this way the effect of digitization on the original input signals can be investigated, and can provide
 a guideline in selecting the most suitable <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>-<a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> system for data transmission.
 The resulting analog values are returned in a TArrayD object, without modification of the original waveform data.

 Note : Make sure to use the same units for <span class="string">"range"</span>, <span class="string">"Vbias"</span> and the analog input signals.

 For further details, please refer to the documentation of the memberfunctions <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>() and <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>().

 Input arguments :

 nbits    : Digital quantization was performed using an nbits <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
 range &gt;0 : The full scale voltage range (Vfs) of the analog signal that corresponds to adc=N-1.
       &lt;0 : |range| is the reference voltage (Vref) of the analog signal that corresponds to the hypothetical adc=N.
 Vbias    : The bias voltage that was added to the analog input signal before digitization.
            If specified, the resulting analog signals will be corrected for the bias voltage.
            For a linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> the correction via Vbias will only be performed if no pedestal array <span class="string">"peds"</span>
            is specified (see below). If the array <span class="string">"peds"</span> is specified, Vbias will be ignored for a linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>.
            For a Log <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> the pedestal values will never be used and bias correction may only be obtained via Vbias.
 Vsig     : (Optional) array to contain the digital input signals.
 peds     : (Optional) array to contain the pedestal values for the individual digital signals.
            The array <span class="string">"peds"</span> must contain (at least) the same number of values as the number of analog input signals.
            If the array <span class="string">"peds"</span> is specified, the pedestals will be subtracted from the corresponding digital signals
            before the conversion to analog signals is performed in case of a linear <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a>.
            For a Log <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> the pedestal values will never be used and bias correction may only be obtained via Vbias.
 B     &gt;1 : Base for a log <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> (e.g. B=10 emulates a Log_10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>).
       =0 : The <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> will be linear
       =1 : The <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> will be a Log_e <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
            Note : When B&gt;0 all (Vbias+Vsig) input values should be positive.
 C        : Code efficiency factor that was used for a Log <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a>.
            Rule of thumb : pow(B,-C) is about the smallest signal/|range| ratio that can be resolved.
            So, for a Log_10 <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> with C=3, the smallest signal that can be resolved is about |range|/1000.
            Note : It is required that C&gt;0.

 Optional output arguments :

 hist  : Histogram with the analog result

 Note :

 In case no <span class="string">"Vsig"</span> array is provided and no waveform is present, just the <a href="./NcDSP.html#NcDSP:ADC" title="TArrayL64 NcDSP::ADC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* Vsig=0,TH1* hist=0,Int_t B=0,Int_t C=3)">ADC</a> and <a href="./NcDSP.html#NcDSP:DAC" title="TArrayD NcDSP::DAC(Int_t nbits,Double_t range,Double_t Vbias=0,TArray* adcs=0,TArray* peds=0,TH1* hist=0,Int_t B=0,Int_t C=3)">DAC</a> specs will be printed
 and in the TArrayD only the adc value corresponding to Vbias is returned.
 This allows to quickly investigate various scenarios without any data treatment.

 The maximum number of bits that is supported is 60 to guarantee identical functioning
 on all machines.

 In case of inconsistent input parameters, no processing is performed and an empty TArrayD is returned.

 The default values are Vbias=0, Vsig=0, peds=0, hist=0, B=0 and C=3.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:SampleAndHold" href="src/NcDSP.cxx.html#mevJG">SampleAndHold</a>(TF1 f, <a href="./ListOfTypes.html#Double_t">Double_t</a> step, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmax, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> loc = -1) const</span><br />
<div class="funccomm"><pre> Perform a Sample-And-Hold operation on the specified function <span class="string">"f"</span>
 in the interval [vmin,vmax], using <span class="string">"step"</span> as the sampling step size.
 The result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>.

 If <span class="string">"f"</span> can be regarded as a pulse generator in time, this mimics a
 sample and hold device with a lock time of <span class="string">"step"</span> time units,
 or equivalently a sampling frequency of 1/step.

 The input argument <span class="string">"loc"</span> determines whether the resulting data
 will be recorded at the start (loc&lt;0), center (loc=0) or end (loc&gt;0)
 of the sampling step size.
 However, in case the recording location of the last sampling step would
 exceed <span class="string">"vmax"</span>, the data will be recorded at the value of <span class="string">"vmax"</span>.

 The default values are hist=0 and loc=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:SampleAndHold@1" href="src/NcDSP.cxx.html#vMEBLE">SampleAndHold</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ns, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> loc = -1, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmin = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmax = -1) const</span><br />
<div class="funccomm"><pre> Perform a Sample-And-Hold operation on the data contained in the stored waveform
 over the sampled interval [jmin,jmax], using <span class="string">"n"</span> original samples as the new sampling step size.
 By convention, the first sample is at j=0.
 The result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>,
 without modification of the original waveform data.

 If the waveform can be regarded as a pulse generator in time, this mimics a
 sample and hold device with a lock time of <span class="string">"n"</span> time units,
 or equivalently a sampling frequency which is reduced by a factor 1/n.

 The input argument <span class="string">"loc"</span> determines whether the resulting data
 will be recorded at the start (loc&lt;0), center (loc=0) or end (loc&gt;0)
 of the new sampling step size.
 However, in case the recording location of the last sampling step would
 exceed <span class="string">"jmax"</span>, the data will be recorded at the value of <span class="string">"jmax"</span>.

 If jmax&lt;=jmin the full data array of the stored waveform will be used.

 The default values are hist=0, loc=-1, jmin=0 and jmax=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:SampleAndSum" href="src/NcDSP.cxx.html#TRMpGD">SampleAndSum</a>(TF1 f, <a href="./ListOfTypes.html#Double_t">Double_t</a> step, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmin, <a href="./ListOfTypes.html#Double_t">Double_t</a> vmax, TH1* hist = 0) const</span><br />
<div class="funccomm"><pre> Perform a Sample-And-Sum operation on the specified function <span class="string">"f"</span>
 in the interval [vmin,vmax], using <span class="string">"step"</span> as the sampling step size.
 The result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>.

 This procedure resembles a Sample-And-Hold operation, but instead of locking
 the data recording during the stepsize, the data that appear within <span class="string">"step"</span>
 are summed c.q. integrated.

 If <span class="string">"f"</span> can be regarded as sampling in time, this mimics a
 Switched Capacitor Array (SCA) with a time gate of <span class="string">"step"</span> time units,
 or equivalently a sampling frequency which is reduced by a factor 1/step.

 The default value is hist=0.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:SampleAndSum@1" href="src/NcDSP.cxx.html#IWFQbE">SampleAndSum</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> ns, TH1* hist, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmin = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a> jmax = -1) const</span><br />
<div class="funccomm"><pre> Perform a Sample-And-Sum operation on the data contained in the stored waveform
 over the sampled interval [jmin,jmax], using <span class="string">"n"</span> original samples as the new sampling step size.
 By convention, the first sample is at j=0.
 The result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>,
 without modification of the original waveform data.

 This procedure resembles a Sample-And-Hold operation, but instead of locking
 the data recording during the stepsize of <span class="string">"n"</span> samplings, the data that appear
 within <span class="string">"n"</span> samplings are summed.

 If the waveform data can be regarded as sampling in time, this mimics a
 Switched Capacitor Array (SCA) with a time gate of <span class="string">"n"</span> time units,
 or equivalently a sampling frequency which is reduced by a factor 1/n.

 If jmax&lt;=jmin the full data array of the stored waveform will be used.

 The default values are hist=0, jmin=0 and jmax=-1.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:FilterMovingAverage" href="src/NcDSP.cxx.html#tq5AU">FilterMovingAverage</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, TString mode, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Perform a Moving Average filter on the loaded input data x[] with averaging over <span class="string">"n"</span> samples.
 The time domain result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>.
 The frequency domain result is returned in the (optional) histogram <span class="string">"hisf"</span>, for which
 the amplitudes may be represented in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The original input data x[] are not modified.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions.

 A Moving Average filter is the optimal time domain filter for reducing random (noise) fluctuations,
 while retaining sharp step responses.
 Large values of <span class="string">"n"</span> will result in a large noise reduction, but the edges of the steps
 become less sharp.
 On the contrary, small values of <span class="string">"n"</span> will result in sharp step edges, but less noise reduction.

 Rule of thumb :

 The noise is reduced by a factor of sqrt(n) and the rise or fall of an edge
 is smeared over <span class="string">"n"</span> samples.

 This filter may be invoked in two different modes, namely Recursion or Convolution.
 The resulting time domain data are equivalent, but are contained in TArrayD objects
 of different length, as outlined below..

 The Recursion mode :

 The straightforward procedure is expressed as :

    y[i]=(1/n)*Sum(j=0,n-1){x[i+j]}  (1)

 To reduce rounding errors and computational speed, the following recursion relation is used :

    y[k]=y[k-1]-(x[k-1]/n)+(x[k+n-1]/n)  (2)

 whereby the first term y[0] is calulated via equation (1).

 In case the number of elements of x[] is m, the number of elements of y[] will <span class="string">"only"</span> be (m-n+1),
 such that the last element of y[] still has been completely computed from all corresponding <span class="string">"n"</span> values of x[].

 The Convolution mode :

 Based on the above, this filter actually represents a convolution with a filter kernel
 that consists of a rectangular pulse of <span class="string">"n"</span> points of height 1/n (i.e. an area of 1).
 In this respect we can regard this filtering as a convolution y[]=x[]*h[] where h[]
 represents the <span class="string">"n"</span> point rectangular pulse filter kernel.
 In this mode, an array x[] with m elements, will result in an array y[] of (m+n-1) elements.
 For further details see the documentation of <a href="./NcDSP.html#NcDSP:Convolve" title="TArrayD NcDSP::Convolve(TH1* hist=0,Int_t* i1=0,Int_t* i2=0,Int_t shift=0)">Convolve</a>().

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 n    : The number of samples that will be averaged over
 mode : To invoke Recursion (mode=<span class="string">"rec"</span>) or Convolution (mode=<span class="string">"conv"</span>) processing.
 hist : (optional) Histogram with the filtered result in the time domain
 i1   : Optional argument (see below)
 i2   : Optional argument (see below)
 hisf : (optional) Histogram with the filtered result (amplitudes) in the frequency domain
 dB   : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting filtered data array for which the filter kernel was fully immersed
 in the input (signal) data x[].
 In other words : The indices range [i1,i2] in the resulting filtered data array y[]
 corresponds to all the y[] elements for which the averaging was completely performed
 over all <span class="string">"n"</span> samples.
 So, values of y[j] with j&lt;i1 or j&gt;i2 contain incomplete summations, and as such should not
 be considered as reliable, especially when x[] contains large variations.
 For an absolute comparison between the x[] and y[] values, one should realize that
 the array sizes of x[] and y[] are different and that x[k] should be compared with y[k+i1].
 The values i1 and i2 (if requested) are indicated by vertical dashed blue lines
 in the time domain histogram.

 Notes :

 1) The returned TArrayD contains the filtered time domain data,
    which can be directly used as input for subsequent DSP processing.
 2) The performance in the frequency domain is very poor, since the <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform
    of the time domain rectangular pulse filter kernel results in a sinc function.
 3) A Bayesian Block analysis (see the class <a href="./NcBlocks.html">NcBlocks</a>) in general provides
    even better results by allowing <span class="string">"n"</span> to vary dynamically based on the data pattern.
    However, the computation time involved for a Bayesian Block analysis
    is vastly larger than for a Moving Average filter.

 The default values are hist=0, i1=0 i2=0, hisf=0 and dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:FilterLowPass" href="src/NcDSP.cxx.html#ZXTNDC">FilterLowPass</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Perform a Low Pass filter on the loaded input data x[] with a frequency cut-off
 specified by <span class="string">"fcut"</span> (see below) and a filter kernel consisting of <span class="string">"n"</span> points (see below).
 The time domain result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>,
 whereas the frequency domain result is returned in the (optional) histogram <span class="string">"hisf"</span>.
 The <span class="string">"hisf"</span> amplitudes may be represented in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The original input data x[] are not modified.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions.

 Note :

 When the input data x[] contains en even (odd) number of samples, then an odd (even) value of <span class="string">"n"</span>
 will result again in an even (odd) number of samples for the filtered data in the time domain.

 The implementation here is based on the Blackman windowed-sinc filtering procedure.

 A Blackman Low Pass filter is an excellent frequency domain filter for seperating
 one band of frequencies from another.
 Large values of <span class="string">"n"</span> will result in a sharp transition between the pass band and the stop band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in a less sharp transition between the
 pass band and the stop band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) between the pass band and the stop band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) The returned TArrayD contains the filtered time domain data,
    which can be directly used as input for subsequent DSP processing.
 2) Repeated application of this filter will further decrease the amplitudes in the stop band.
 3) Actually this filter represents a convolution with a time domain filter kernel
    that consists of a sinc pulse window of <span class="string">"n"</span> points and an area of 1.
 4) The performance in the time domain is very poor, since the (inverse) <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform
    of the frequency domain step pulse filter kernel results in a sinc function.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 fcut   : The cut-off frequency expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;fcut&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer (see adaptn below)
 hisf   : (optional) Histogram with the filtered result (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filtered result in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting filtered data array for which the filter kernel was fully immersed
 in the input (signal) data.
 These values i1 and i2 (if requested) are indicated by vertical
 dashed blue lines in the time domain histogram.

 The default values are hisf=0, dB-<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0, i1=0, i2=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:FilterHighPass" href="src/NcDSP.cxx.html#DoXRg">FilterHighPass</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Perform a High Pass filter on the loaded input data x[] with a frequency cut-off
 specified by <span class="string">"fcut"</span> (see below) and a filter kernel consisting of <span class="string">"n"</span> points (see below).
 The time domain result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>,
 whereas the frequency domain result is returned in the (optional) histogram <span class="string">"hisf"</span>.
 The <span class="string">"hisf"</span> amplitudes may be represented in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The original input data x[] are not modified.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions.

 Note :

 When the input data x[] contains en even (odd) number of samples, then an odd (even) value of <span class="string">"n"</span>
 will result again in an even (odd) number of samples for the filtered data in the time domain.

 The implementation here is based on a spectrally inverted Blackman windowed-sinc Low Pass filter.

 A Blackman High Pass filter is an excellent frequency domain filter for seperating
 one band of frequencies from another.
 Large values of <span class="string">"n"</span> will result in a sharp transition between the pass band and the stop band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in a less sharp transition between the
 pass band and the stop band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) between the pass band and the stop band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) The returned TArrayD contains the filtered time domain data,
    which can be directly used as input for subsequent DSP processing.
 2) Repeated application of this filter will further decrease the amplitudes in the stop band.
 3) Actually this filter represents a convolution with a time domain filter kernel
    that consists of a sinc pulse window of <span class="string">"n"</span> points and an area of 1.
 4) The performance in the time domain is very poor, since the (inverse) <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform
    of the frequency domain step pulse filter kernel results in a sinc function.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 fcut   : The cut-off frequency expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;fcut&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer (see adaptn below).
 hisf   : (optional) Histogram with the filtered result (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filtered result in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting filtered data array for which the filter kernel was fully immersed
 in the input (signal) data.
 These values i1 and i2 (if requested) are indicated by vertical
 dashed blue lines in the time domain histogram.

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0, i1=0, i2=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:FilterBandPass" href="src/NcDSP.cxx.html#WLjgBD">FilterBandPass</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Perform a Band Pass filter on the loaded input data x[] in the frequency band
 specified by <span class="string">"f1"</span> and <span class="string">"f2"</span> (see below) and a filter kernel consisting of <span class="string">"n"</span> points (see below).
 The time domain result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>,
 whereas the frequency domain result is returned in the (optional) histogram <span class="string">"hisf"</span>.
 The <span class="string">"hisf"</span> amplitudes may be represented in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The original input data x[] are not modified.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions.

 Note :

 When the input data x[] contains en even (odd) number of samples, then an odd (even) value of <span class="string">"n"</span>
 will result again in an even (odd) number of samples for the filtered data in the time domain.

 The implementation here is based on a combination of Blackman windowed-sinc Low Pass and High Pass filters,
 which is spectrally inverted.

 A Blackman Band Pass filter is an excellent frequency domain filter for passing
 only a certain band of frequencies.
 Large values of <span class="string">"n"</span> will result in sharp transitions at the edges of the pass band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in less sharp transitions at the edges
 of the pass band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) at the edges of the pass band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) The returned TArrayD contains the filtered time domain data,
    which can be directly used as input for subsequent DSP processing.
 2) Repeated application of this filter will further decrease the amplitudes outside the selected band.
 3) Actually this filter represents a convolution with a time domain filter kernel
    that consists of a sinc pulse window of <span class="string">"n"</span> points and an area of 1.
 4) The performance in the time domain is very poor, since the (inverse) <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform
    of a frequency domain rectangular pulse filter kernel results in a sinc function.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 f1     : The lower bound of the frequency band expressed as a fraction of the sampling frequency
 f2     : The upper bound of the frequency band expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;f1&lt;0.5 and 0&lt;f2&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer (see adaptn below).
 hisf   : (optional) Histogram with the filtered result (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filtered result in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting filtered data array for which the filter kernel was fully immersed
 in the input (signal) data.
 These values i1 and i2 (if requested) are indicated by vertical
 dashed blue lines in the time domain histogram.

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0, i1=0, i2=0 and adaptn=TRUE.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:FilterBandReject" href="src/NcDSP.cxx.html#gXwDnE">FilterBandReject</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Perform a Band Reject filter on the loaded input data x[] in the frequency band
 specified by <span class="string">"f1"</span> and <span class="string">"f2"</span> (see below) and a filter kernel consisting of <span class="string">"n"</span> points (see below).
 The time domain result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>,
 whereas the frequency domain result is returned in the (optional) histogram <span class="string">"hisf"</span>.
 The <span class="string">"hisf"</span> amplitudes may be represented in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The original input data x[] are not modified.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions.

 Note :

 When the input data x[] contains en even (odd) number of samples, then an odd (even) value of <span class="string">"n"</span>
 will result again in an even (odd) number of samples for the filtered data in the time domain.

 The implementation here is based on a combination of Blackman windowed-sinc Low Pass and High Pass filters.

 A Blackman Band Reject filter is an excellent frequency domain filter for suppressing
 a certain band of frequencies.
 Large values of <span class="string">"n"</span> will result in sharp transitions at the edges of the rejected band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in less sharp transitions at the edges
 of the rejected band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) at the edges of the rejected band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) The returned TArrayD contains the filtered time domain data,
    which can be directly used as input for subsequent DSP processing.
 2) Repeated application of this filter will further decrease the amplitudes inside the selected band.
 3) Actually this filter represents a convolution with a time domain filter kernel
    that consists of a sinc pulse window of <span class="string">"n"</span> points and an area of 1.
 4) The performance in the time domain is very poor, since the (inverse) <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform
    of a frequency domain rectangular pulse filter kernel results in a sinc function.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 f1     : The lower bound of the frequency band expressed as a fraction of the sampling frequency
 f2     : The upper bound of the frequency band expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;f1&lt;0.5 and 0&lt;f2&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer (see adaptn below).
 hisf   : (optional) Histogram with the filtered result (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filtered result in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting filtered data array for which the filter kernel was fully immersed
 in the input (signal) data.
 These values i1 and i2 (if requested) are indicated by vertical
 dashed blue lines in the time domain histogram.

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0, i1=0, i2=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:FilterMultiBand" href="src/NcDSP.cxx.html#Bp2JmD">FilterMultiBand</a>(TArray&amp; freqs, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i1 = 0, <a href="./ListOfTypes.html#Int_t">Int_t</a>* i2 = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Perform a MultiBand filter on the loaded input data x[] in various frequency bands as
 specified by the array <span class="string">"freqs"</span> (see below) and filter kernels consisting of <span class="string">"n"</span> points (see below).
 The time domain result is returned in a TArrayD object and (optionally) in the histogram <span class="string">"hist"</span>,
 whereas the frequency domain result is returned in the (optional) histogram <span class="string">"hisf"</span>.
 The <span class="string">"hisf"</span> amplitudes may be represented in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The original input data x[] are not modified.
 The input data x[] have to be entered as real numbers by one of the <a href="./NcDSP.html#NcDSP:Load" title="void NcDSP::Load(Int_t n,Double_t* re,Double_t* im=0,Float_t f=-1) or overloads">Load</a>() member functions.

 Note :

 When the input data x[] contains en even (odd) number of samples, then an odd (even) value of <span class="string">"n"</span>
 will result again in an even (odd) number of samples for the filtered data in the time domain.

 The procedure is based on a convolution of the various provided Blackman
 single Low Pass and/or High Pass and/or Band Pass and/or Band Reject filters.

 Large values of <span class="string">"n"</span> will result in sharp transitions at the edges of the specified bands,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in less sharp transitions at the edges
 of the specified bands, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) at the edges of the specified bands (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) The size of the TArrayD <span class="string">"freqs"</span> should match exactly twice the number of
    frequency bands to be specified (see below).
 2) The returned TArrayD contains the filtered time domain data,
    which can be directly used as input for subsequent DSP processing.
 3) Specifying the same frequency band more than once will further suppress the unwanted frequencies.
 4) The performance in the time domain is very poor, since the (inverse) <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform
    of a frequency domain rectangular pulse filter kernel results in a sinc function.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 freqs  : Array containing the lower and upper bounds of the frequency bands expressed as
          fractions of the sampling frequency.
          The array elements represent the various pairs [flow,fup] to define the frequency bands,
          ordered as (f1low,f1up,f2low,f2up,...).
          The following conventions are used :
          flow&gt;0 and fup&gt;0 --&gt; Apply a Band Pass filter over [flow,fup]
          flow&lt;0 and fup&lt;0 --&gt; Apply a Band Reject filter over [|flow|,|fup|]
          flow&lt;0 and fup&gt;0 --&gt; Apply a Low Pass filter with fcut=fup
          flow&gt;0 and fup&lt;0 --&gt; Apply a High Pass filter with fcut=flow
 n      : The number of values in the corresponding filter kernels
          For best functionality this must be an odd integer (see adaptn below).
 hisf   : (optional) Histogram with the filtered result (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filtered result in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The (optional) arguments i1 and i2 provide the range [i1,i2] in the
 resulting filtered data array for which the filter kernel was fully immersed
 in the input (signal) data.
 These values i1 and i2 (if requested) are indicated by vertical
 dashed blue lines in the time domain histogram.

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0, i1=0, i2=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:GetMovingAverageKernel" href="src/NcDSP.cxx.html#ezJ12C">GetMovingAverageKernel</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0)</span><br />
<div class="funccomm"><pre> Provide via the returned TArrayD an n-point time domain Moving Average Filter kernel.
 The optional argument <span class="string">"hisf"</span> may be used to obtain a histogram of the frequency domain kernel
 with the amplitude in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The optional argument <span class="string">"hist"</span> may be used to obtain a (zero padded) histogram of the time domain kernel.

 A Moving Average filter is the optimal time domain filter for reducing random (noise) fluctuations,
 while retaining sharp step responses.
 Large values of <span class="string">"n"</span> will result in a large noise reduction, but the edges of the steps
 become less sharp.
 On the contrary, small values of <span class="string">"n"</span> will result in sharp step edges, but less noise reduction.

 Rule of thumb :

 The noise is reduced by a factor of sqrt(n) and the rise or fall of an edge
 is smeared over <span class="string">"n"</span> samples.

 Notes :

 1) Actually this filter kernel consists of a time domain rectangular pulse of <span class="string">"n"</span> points
    and an area of 1.
 2) The performance in the frequency domain is very poor, since the <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform
    of the time domain rectangular pulse filter kernel results in a sinc function.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 n    : The number of samples that will be averaged over
 hisf : (optional) Histogram with the filter kernel (amplitudes) in the frequency domain
 dB   : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist : (optional) Histogram with the filter kernel in the time domain

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> and hist=0.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:GetLowPassKernel" href="src/NcDSP.cxx.html#a_gTVD">GetLowPassKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Provide via the returned TArrayD an n-point time domain Low Pass Filter kernel
 with cut-off frequency <span class="string">"fcut"</span> expressed as a fraction of the sampling frequency.
 The optional argument <span class="string">"hisf"</span> may be used to obtain a histogram of the kernel
 in the frequency domain with the amplitude in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The optional argument <span class="string">"hist"</span> may be used to obtain a (zero padded) histogram of the time domain kernel.

 The implementation here is based on the Blackman windowed-sinc filtering procedure.

 A Blackman Low Pass filter is an excellent frequency domain filter for seperating
 one band of frequencies from another.
 Large values of <span class="string">"n"</span> will result in a sharp transition between the pass band and the stop band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in a less sharp transition between the
 pass band and the stop band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) between the pass band and the stop band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) Repeated application of this filter will further decrease the amplitudes in the stop band.
 2) Actually this filter kernel consists of a time domain sinc pulse window of <span class="string">"n"</span> points
    and an area of 1.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 fcut   : The cut-off frequency expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;fcut&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer (see adaptn below)
 hisf   : (optional) Histogram with the filter kernel (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filter kernel in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:GetHighPassKernel" href="src/NcDSP.cxx.html#rvQE8D">GetHighPassKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> fcut, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Provide via the returned TArrayD an n-point time domain High Pass Filter kernel
 with cut-off frequency <span class="string">"fcut"</span> expressed as a fraction of the sampling frequency.
 The optional argument <span class="string">"hisf"</span> may be used to obtain a histogram of the kernel
 in the frequency domain with the amplitude in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The optional argument <span class="string">"hist"</span> may be used to obtain a (zero padded) histogram of the time domain kernel.

 The implementation here is based on a spectrally inverted Blackman windowed-sinc Low Pass filter.

 A Blackman High Pass filter is an excellent frequency domain filter for seperating
 one band of frequencies from another.
 Large values of <span class="string">"n"</span> will result in a sharp transition between the pass band and the stop band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in a less sharp transition between the
 pass band and the stop band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) between the pass band and the stop band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) Repeated application of this filter will further decrease the amplitudes in the stop band.
 2) Actually this filter kernel consists of a time domain sinc pulse window of <span class="string">"n"</span> points
    and an area of 1.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 fcut   : The cut-off frequency expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;fcut&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer (see adaptn below).
 hisf   : (optional) Histogram with the filter kernel (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filter kernel in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:GetBandPassKernel" href="src/NcDSP.cxx.html#Ytpn9C">GetBandPassKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Provide via the returned TArrayD an n-point time domain Band Pass Filter kernel
 for the frequency band [f1,f2] expressed as fractions of the sampling frequency.
 The optional argument <span class="string">"hisf"</span> may be used to obtain a histogram of the kernel
 in the frequency domain with the amplitude in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The optional argument <span class="string">"hist"</span> may be used to obtain a (zero padded) histogram of the time domain kernel.

 The implementation here is based on a combination of Blackman windowed-sinc Low Pass and High Pass filters,
 which is spectrally inverted.

 A Blackman Band Pass filter is an excellent frequency domain filter for passing
 only a certain band of frequencies.
 Large values of <span class="string">"n"</span> will result in sharp transitions at the edges of the pass band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in less sharp transitions at the edges
 of the pass band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) at the edges of the pass band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) Repeated application of this filter will further decrease the amplitudes outside the selected band.
 2) Actually this filter kernel consists of a time domain sinc pulse window of <span class="string">"n"</span> points
    and an area of 1.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 f1     : The lower bound of the frequency band expressed as a fraction of the sampling frequency
 f2     : The upper bound of the frequency band expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;f1&lt;0.5 and 0&lt;f2&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer (see adaptn below).
 hisf   : (optional) Histogram with the filter kernel (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filter kernel in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:GetBandRejectKernel" href="src/NcDSP.cxx.html#tqh5IB">GetBandRejectKernel</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f1, <a href="./ListOfTypes.html#Double_t">Double_t</a> f2, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Provide via the returned TArrayD an n-point time domain Band Reject Filter kernel
 for the frequency band [f1,f2] expressed as fractions of the sampling frequency.
 The optional argument <span class="string">"hisf"</span> may be used to obtain a histogram of the kernel
 in the frequency domain with the amplitude in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The optional argument <span class="string">"hist"</span> may be used to obtain a (zero padded) histogram of the time domain kernel.

 The implementation here is based on a combination of Blackman windowed-sinc Low Pass and High Pass filters.

 A Blackman Band Reject filter is an excellent frequency domain filter for suppressing
 a certain band of frequencies.
 Large values of <span class="string">"n"</span> will result in sharp transitions at the edges of the rejected band,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in less sharp transitions at the edges
 of the rejected band, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) at the edges of the rejected band (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) Repeated application of this filter will further decrease the amplitudes inside the selected band.
 2) Actually this filter kernel consists of a time domain sinc pulse window of <span class="string">"n"</span> points
    and an area of 1.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 f1     : The lower bound of the frequency band expressed as a fraction of the sampling frequency
 f2     : The upper bound of the frequency band expressed as a fraction of the sampling frequency
          For proper functionality one should choose 0&lt;f1&lt;0.5 and 0&lt;f2&lt;0.5, because of the
          underlying <a href="./NcDSP.html#NcDSP:Fourier" title="void NcDSP::Fourier(TString mode,TH1* hist=0,TString sel=&quot;none&quot;)">Fourier</a> transform.
 n      : The number of values in the filter kernel
          For best functionality this must be an odd integer.
 hisf   : (optional) Histogram with the filter kernel (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filter kernel in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname">TArrayD <a class="funcname" name="NcDSP:GetMultiBandKernel" href="src/NcDSP.cxx.html#ANOHp">GetMultiBandKernel</a>(TArray&amp; freqs, <a href="./ListOfTypes.html#Int_t">Int_t</a> n, TH1* hisf = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>, TH1* hist = 0, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> adaptn = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</span><br />
<div class="funccomm"><pre> Provide via the returned TArrayD a time domain Multi Band Filter kernel in various frequency bands
 specified by the array <span class="string">"freqs"</span> (see below) and filter kernels consisting of <span class="string">"n"</span> points each (see below).
 The optional argument <span class="string">"hisf"</span> may be used to obtain a histogram of the kernel
 in the frequency domain with the amplitude in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 The optional argument <span class="string">"hist"</span> may be used to obtain a (zero padded) histogram of the time domain kernel.

 The procedure is based on a convolution of the various provided Blackman
 single Low Pass and/or High Pass and/or Band Pass and/or Band Reject filters.

 Large values of <span class="string">"n"</span> will result in sharp transitions at the edges of the specified bands,
 but may result in <a href="./ListOfTypes.html#long">long</a>(er) computation times.
 On the contrary, small values of <span class="string">"n"</span> will result in less sharp transitions at the edges
 of the specified bands, but result in <a href="./ListOfTypes.html#short">short</a>(er) computation times.

 Rule of thumb :

 The transition bandwidth (BW) at the edges of the specified bands (aka roll-off)
 may be approximated as BW=4/n, where BW is expressed as a fraction of the sampling frequency.

 Notes :

 1) The size of the TArrayD <span class="string">"freqs"</span> should match exactly twice the number of
    frequency bands to be specified (see below).
 2) Specifying the same frequency band more than once will further suppress the unwanted frequencies.

 For details about the procedure, please refer to the excellent textbook :
 <span class="string">"The Scientist and Engineer's Guide to Digital Signal Processing"</span> by Steven W. Smith,
 which is online available at http://www.dspguide.com/pdfbook.htm

 Input arguments :

 freqs  : Array containing the lower and upper bounds of the frequency bands expressed as
          fractions of the sampling frequency.
          The array elements represent the various pairs [flow,fup] to define the frequency bands,
          ordered as (f1low,f1up,f2low,f2up,...).
          The following conventions are used :
          flow&gt;0 and fup&gt;0 --&gt; Apply a Band Pass filter over [flow,fup]
          flow&lt;0 and fup&lt;0 --&gt; Apply a Band Reject filter over [|flow|,|fup|]
          flow&lt;0 and fup&gt;0 --&gt; Apply a Low Pass filter with fcut=fup
          flow&gt;0 and fup&lt;0 --&gt; Apply a High Pass filter with fcut=flow
          In case flow=0 or fup=0 the pair [flow,fup] is neglected.
 n      : The number of points in the corresponding filter kernels
          For best functionality this must be an odd integer (see adaptn below)
 hisf   : (optional) Histogram with the filter kernel (amplitudes) in the frequency domain
 dB     : Amplitudes of <span class="string">"hisf"</span> are represented in decibel (<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (<a href="./ListOfTypes.html#Bool_t">kFALSE</a>)
 hist   : (optional) Histogram with the filter kernel in the time domain
 adaptn : If adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> an even value of <span class="string">"n"</span> will be increased by 1 to obtain an odd value

 The default values are hisf=0, dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>, hist=0 and adaptn=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="NcDSP:HistogramFilterFFT" href="src/NcDSP.cxx.html#azTrWD">HistogramFilterFFT</a>(TArray* h, TH1* hisf, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> dB, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> kernel, TH1* hist = 0)</span><br />
<div class="funccomm"><pre> Internal member function to provide a filter kernel or filter result histogram in the frequency domain,
 based on the time domain filter kernel or time domain filter result data contained in <span class="string">"h"</span>.
 The amplitude may be represented in decibel (dB=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>) or linear (dB=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>).
 In case of filter kernel data (kernel=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>), the histogram will be rescaled
 such that the maximum value is at 1 for linear amplitudes or 0 for amplitudes in dB.
 The optional argument <span class="string">"hist"</span> may be used to obtain a (zero padded) histogram of the time domain kernel.
 However, in case kernel=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>, the <span class="string">"hist"</span> histogram will be left empty.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./#TObject:TObject" title="TObject TObject::TObject() or overloads">TObject</a>* <a class="funcname" name="NcDSP:Clone" href="src/NcDSP.cxx.html#xH8DS">Clone</a>(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">""</span>) const</span><br />
<div class="funccomm"><pre> Make a deep copy of the current object and provide the pointer to the copy.
 This memberfunction enables automatic creation of new objects of the
 correct type depending on the object type, a feature which may be very useful
 for containers like <a href="./NcEvent.html">NcEvent</a> when adding objects in case the
 container owns the objects.
</pre></div>
</div>

<br />
<!--SIGNATURE-->
<div id="footer">

<em>&raquo; Last changed: Tue Dec  5 12:09:08 2023 </em><em>&raquo; Last generated: 2023-12-05 12:09</em><br />
<em>This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to <a href="mailto:rootdev@cern.ch">ROOT support</a>.</em>
</div>
</div>
</body>
</html>
